# -*- coding: utf-8 -*-

################################################
###### Copyright (c) 2016, Alexandre Popoff 
###

import numpy as np
import itertools

class MonoidAction:
    """Defines a monoid action, i.e. a functor from a monoid-as-category to Sets or Rel.

    Variables
    ----------
    objects : dictionary of musical elements. Keys are string describing the elements (for example "C"), values are indices.
    generators : dictionary of monoid operations, which are generators of the monoid.
                Keys are string describing the operations (for example "I^3"), values are boolean matrices representing the action of the operation.
    operations : dictionary of monoid operations. Keys are string describing the operations (for example "I^3"), values are boolean matrices representing the action of the operation.
    SIMPLY_TRANSITIVE: boolean, indicating whether the action is simply transitive or not.
    """
    def __init__(self):
        self.objects = {}
        self.generators = {}
        self.operations = {}
        self.SIMPLY_TRANSITIVE=False

    def add_objects(self,object_list):
        """Add musical elements to the monoid action.

        Parameters
        ----------
        object_list : a list of strings describing the musical elements

        Returns
        -------
        None
        """
        N = len(self.objects)
        for i,x in enumerate(object_list):
            self.objects[x]=i+N

    def add_generator(self,gen_name,gen_matrix):
        """Add an operation as a generator to the monoid action.

        Parameters
        ----------
        gen_name : a string describing the operation
        gen_matrix : a boolean matrix representing the action of the generator

        Returns
        -------
        None
        """
        self.generators[gen_name] = gen_matrix
        
    def apply_operation(self,operation_name,element_name):
        """Apply a given operation on a given musical element.

        Parameters
        ----------
        operation_name : a string describing the operation
        element_name : a string describing the musical element

        Returns
        -------
        A list of all possible images
        """
        idx_element = self.objects[element_name]
        op = self.operations[operation_name]
        list_indices = np.where(op[:,idx_element])[0]
        return [x for x in self.objects for y in list_indices if self.objects[x]==y]

    def get_operation(self,elem_1,elem_2):
        """Determines the possible operations relating an element to another.

        Parameters
        ----------
        elem_1 : a string describing a musical element
        elem_2 : a string describing the image of elem_1

        Returns
        -------
        A list of all possible operations relating elem_1 to elem_2
        """
        idx_1 = self.objects[elem_1]
        idx_2 = self.objects[elem_2]

        return [op for op in self.operations if self.operations[op][idx_2,idx_1] ]


    def mult(self,op_2,op_1):
        """Multiplies two operations g and f and returns gf.

        Parameters
        ----------
        op_2 : a string describing an operation (g)
        op_1 : a string describing an operation (f)

        Returns
        -------
        The operation corresponding to op_2*op_1
        """
        m = (self.operations[op_2].dot(self.operations[op_1])>0)
        for x in self.operations:
            if np.array_equal(m,self.operations[x]):
                return x

    def generate_monoid(self):
        """Assuming that generators have been specified, builds all operations in the monoid generated by the given generators.

        Parameters
        ----------
        None

        Returns
        -------
        None. The monoid action operations is updated after a call to this method.
        """
        self.operations = self.generators.copy()
        self.operations["e"] = np.eye(len(self.objects),dtype=bool)
        new_liste = self.generators.copy()
        added_liste = self.generators.copy()

        while(len(added_liste)>0):
            added_liste = {}
            for name_x in new_liste:
                for name_g in self.generators:
                    elem_name = name_g+name_x
                    elem_matrix = (self.generators[name_g].dot(new_liste[name_x])>0)
                    c=0
                    for name_y in self.operations:
                        if np.array_equal(self.operations[name_y],elem_matrix):
                            c=1
                    if c==0:
                        added_liste[elem_name] = elem_matrix
                        self.operations[elem_name] = elem_matrix
            new_liste = added_liste


    def get_automorphisms(self):
        """Returns all automorphisms of the monoid as a list of dictionaries.
        
        Parameters
        ----------
        None

        Returns
        -------
        A list of dictionaries. Each dictionary maps the generators (the keys) to their image in the monoid (the values) 
        """
        l1 = self.generators.keys()
        l2 = self.operations.keys()
        list_automorphisms = []
        
        ## Get all maps from the generator set to itself
        for mapping in itertools.permutations(l2,len(l1)):
            ## Builds a dictionary representing the map...
            autom_dict={}
            for x,y in zip(l1,mapping):
                autom_dict[x]=y
            ## Tests if the given map of generators is indeed an automorphism...
            if self.is_automorphism(autom_dict)[0]:
                list_automorphisms.append(autom_dict)
        return list_automorphisms

    def is_automorphism(self,autom_dict,full_map=False):
        """Checks if a given map of operations is an automorphism.
        
        Parameters
        ----------
        autom_dict : dictionary, whose keys are generators of the monoid, and values are the image of the generators in the monoid by the map
        full_map :  if True, returns the full mapping of all the operations in the monoid as a dictionary.

        Returns
        -------
        A tuple (valid,fullmap) where:
            - valid is a boolean indicating if the map defined by autom_dict is an automorphism
            - fullmap is None if full_map=False, a dictionary mapping all operations of the monoid (keys) to their image (values) if full_map=True.
        """
        new_liste = self.generators.keys()
        added_liste = self.generators.keys()
        full_mapping = autom_dict.copy()
        full_mapping["e"]="e"

        ## This is a variant of the monoid generation method.
        ## It generates the monoid and their images by the map of generators.
        ## If it does not give a multi-valued function, and if it generates the same number of elements
        ## then it is a bijection, hence a valid automorphism

        while(len(added_liste)>0):
            added_liste = []
            for name_x in new_liste:
                for name_g in self.generators:
                    name_product = self.mult(name_g,name_x)
                    name_imageproduct = self.mult(full_mapping[name_g],full_mapping[name_x])
                    if not name_product in full_mapping.keys():
                        added_liste.append(name_product)
                        full_mapping[name_product] = name_imageproduct
                    else:
                        ## If the generated element already exists, we check that its existing image corresponds
                        ## to the image which has just been calculated
                        if not full_mapping[name_product] == name_imageproduct:
                            ## We have a multi-valued function so the algorithm stops there
                            return (False,None)
            new_liste = added_liste[:]

        if not len(np.unique(full_mapping.values()))==len(self.operations.keys()):
            return (False,None)
        else:
            if full_map:
                return (True,full_mapping)
            else:
                return (True,None)
            
    def element_Rclass(self,op_name):
        """Generates the R class for a given operation x in the monoid, i.e. all elements y of the monoid such that we have xRy for Green's R relation.
        Recall that we have xRy if xS=yS where S is the monoid.
    

        Parameters
        ----------
        op_name : a string describing an operation of the monoid.

        Returns
        -------
        A list of operations related to op_name by Green's R relation. 
        """
        list_Req = []
        I1 = np.unique([self.mult(op_name,x) for x in self.operations])
        for op in self.operations.keys():
            I2 = np.unique([self.mult(op,x) for x in self.operations])
            if sorted(I2) == sorted(I1):
                list_Req.append(op)
        return list_Req

    def element_Lclass(self,op_name):
        """Generates the L class for a given operation x in the monoid, i.e. all elements y of the monoid such that we have xLy for Green's L relation.
        Recall that we have xLy if Sx=Sy where S is the monoid.
    

        Parameters
        ----------
        op_name : a string describing an operation of the monoid.

        Returns
        -------
        A list of operations related to op_name by Green's L relation. 
        """
        list_Req = []
        I1 = np.unique([self.mult(x,op_name) for x in self.operations])
        for op in self.operations.keys():
            I2 = np.unique([self.mult(x,op) for x in self.operations])
            if sorted(I2) == sorted(I1):
                list_Req.append(op)
        return list_Req

    def get_Rclasses(self):
        """Computes all R classes for the monoid.
    
        Parameters
        ----------
        None

        Returns
        -------
        A list of lists, each list being an R class.
        """
        list_op = zip(self.operations.keys(),[0]*len(self.operations.keys()))
        R_classes = []
        for x,visited in list_op:
            if not visited:
                R_class = self.element_Rclass(x)
                R_classes.append(R_class)
                for i,(y,flag) in enumerate(list_op):
                    if y in R_class:
                        list_op[i]=(y,1)
        return R_classes

    def get_Lclasses(self):
        """Computes all L classes for the monoid.
    
        Parameters
        ----------
        None

        Returns
        -------
        A list of lists, each list being an L class.
        """
        list_op = zip(self.operations.keys(),[0]*len(self.operations.keys()))
        L_classes = []
        for x,visited in list_op:
            if not visited:
                L_class = self.element_Lclass(x)
                L_classes.append(L_class)
                for i,(y,flag) in enumerate(list_op):
                    if y in L_class:
                        list_op[i]=(y,1)
        return L_classes

    def get_leftIdeals(self):
        """Computes all left ideals for the monoid.
        A left ideal is a subset X of the monoid S, such that for any operation m in the monoid, we have mX included in X.
        In other words, if x belongs to X, then Sx is included in X. Thus, any left ideal can be decomposed as the union of distinct L classes.
    
        Parameters
        ----------
        None

        Returns
        -------
        A list of lists, each list being a left ideal of the monoid.
        """
        leftIdeals = []

        L_classes = self.get_Lclasses()
        for i in range(len(L_classes)+1):
            for x in itertools.combinations(L_classes, i):
                subset = list(itertools.chain.from_iterable(x))
                if self.is_leftIdeal(subset):
                    leftIdeals.append(subset)

        return leftIdeals
		
    def is_leftIdeal(self,S):
        """Checks if a subset S is a left ideal.
            
        Parameters
        ----------
        S : list of operations in the monoid.

        Returns
        -------
        A boolean indicating if S is a left ideal.
        """
        for m in S:
            for f in self.operations:
                t = self.mult(f,m)
                if not t in S:
                    return False
        return True
        
    def get_rightIdeals(self):
        """Computes all right ideals for the monoid.
        A right ideal is a subset X of the monoid S, such that for any operation m in the monoid, we have Xm included in X.
        In other words, if x belongs to X, then xS is included in X. Thus, any right ideal can be decomposed as the union of distinct R classes.
    
        Parameters
        ----------
        None

        Returns
        -------
        A list of lists, each list being a right ideal of the monoid.
        """
        rightIdeals = []

        R_classes = self.get_Rclasses()
        for i in range(len(R_classes)+1):
            for x in itertools.combinations(R_classes, i):
                subset = list(itertools.chain.from_iterable(x))
                if self.is_rightIdeal(subset):
                    rightIdeals.append(subset)

        return rightIdeals
		
    def is_rightIdeal(self,S):
        """Checks if a subset S is a right ideal.
            
        Parameters
        ----------
        S : list of operations in the monoid.

        Returns
        -------
        A boolean indicating if S is a right ideal.
        """
        for m in S:
            for f in self.operations:
                t = self.mult(m,f)
                if not t in S:
                    return False
        return True
	

