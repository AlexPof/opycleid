{
    "docs": [
        {
            "location": "/",
            "text": "Opycleid: The Python library for transformational music analysis\n\n\nWelcome to Opycleid\n\n\nOpycleid is a Python library for \ntransformational music analysis (TMT)\n, a field of musicology\nwhich studies transformations between musical objects (notes, chords, durations, etc.)\nfrom a mathematical point of view. This field was initiated by David Lewin in the 1980s, relying mainly\non mathematical group theory, and later developed and extended using elements of \ncategory theory\n.\n\n\nThe use of this library assumes that one is familiar with the basic notions in transformational music theory.\nHere are a few links for those who would be interested in discovering this subject.\n\n\n\n\nThe \nWikipedia page\n on the subject.\n\n\nA \nseries of blog posts introducing transformational music theory\n.\n\n\nThe book of David Lewin, where he first defined its group-theoretical approach of \ngeneralized musical intervals\n: Lewin, D.: Generalized Musical Intervals and Transformations, Yale University Press: New Haven, CT, 1987.\n\n\n\n\n\n\nGuiding principles\n\n\n\n\nUser-friendly\n: Opycleid provides ready-to-use classes for the common groups and monoids encountered in TMT, such as the \n T\\text{/}I \n group or the \n \\text{PRL} \n group usually found in neo-Riemannian theory. These classes provides methods for determining, multiplying, and applying musical transformations. For, one can start analyzing chords in just a few lines of Python, as shown below.\n\n\n\n\nfrom opycleid.musicmonoids import TI_Group_Triads\n\nmy_group = TI_Group_Triads()\nprint (my_group.get_operation(\nC_M\n,\nB_m\n)) ## ['I6']\nprint (my_group.apply_operation(\nI5\n,\nE_m\n)) ## ['Fs_M']\n\n\n\n\n\n\n\n\nGeneralizability\n: TMT has mainly been applied to the analysis of relations between notes and chords, but it can in fact be applied to any musical object, such as durations, time-spans, rhythms, etc. Opycleid takes a very general approach to TMT by considering \ncategory actions\n in \n \\mathbf{Rel} \n, i.e. faithful functors from a small category to the 2-category \n \\mathbf{Rel} \n of finite sets and relations between them. The elements of these sets are specified as strings and can represent any musical object.\n\n\n\n\n\n\nCustomizability\n: though the usual musical groups and monoids are already implemented in Opycleid, custom monoids can be generated by specifying objects and morphisms. Their definition is made easy by the use of standard Python primitives (dictionaries and lists).\n\n\n\n\n\n\nWhat it is not\n: to allow the user to define his own category actions, Opycleid implements some routines which can be found in computer algebra systems such as GAP and SageMath. However, Opycleid is focused on musical applications, and is therefore not meant to be as complete as these softwares. In particular, Opycleid does not fully implement category theory (categories, functors, natural transformations, etc.), but focuses on faithful functors to \n \\mathbf{Rel} \n, which can be more easily implemented.\n\n\n\n\n\n\n\n\nUser installation\n\n\nThe easiest way to install Opycleid is using \npip\n:\n\n\n$ pip install opycleid\n\n\n\nOpycleid can also be installed directly from source:\n\n\n$ python setup.py install\n\n\n\n\n\nSupport\n\n\nBug reports and features requests (only)\n can be posted in \nGitHub issues\n.\n\n\n\n\nWhy this name, Opycleid ?\n\n\nThe \nophicleide\n is a keyed brass instrument from the 19th century.\nFrom the greek ophis (\u1f44\u03c6\u03b9\u03c2) \"serpent\" (hence the perfect name for a Python library) + kleis (\u03ba\u03bb\u03b5\u03af\u03c2) \"keys\", it means a serpent with keys, the \nserpent\n being an older instrument it evolved from.\n\n\n\n\nThe ophicleide was later superseded by the tuba, which was considered more reliable in terms of tone production.",
            "title": "Home"
        },
        {
            "location": "/#opycleid-the-python-library-for-transformational-music-analysis",
            "text": "",
            "title": "Opycleid: The Python library for transformational music analysis"
        },
        {
            "location": "/#welcome-to-opycleid",
            "text": "Opycleid is a Python library for  transformational music analysis (TMT) , a field of musicology\nwhich studies transformations between musical objects (notes, chords, durations, etc.)\nfrom a mathematical point of view. This field was initiated by David Lewin in the 1980s, relying mainly\non mathematical group theory, and later developed and extended using elements of  category theory .  The use of this library assumes that one is familiar with the basic notions in transformational music theory.\nHere are a few links for those who would be interested in discovering this subject.   The  Wikipedia page  on the subject.  A  series of blog posts introducing transformational music theory .  The book of David Lewin, where he first defined its group-theoretical approach of  generalized musical intervals : Lewin, D.: Generalized Musical Intervals and Transformations, Yale University Press: New Haven, CT, 1987.",
            "title": "Welcome to Opycleid"
        },
        {
            "location": "/#guiding-principles",
            "text": "User-friendly : Opycleid provides ready-to-use classes for the common groups and monoids encountered in TMT, such as the   T\\text{/}I   group or the   \\text{PRL}   group usually found in neo-Riemannian theory. These classes provides methods for determining, multiplying, and applying musical transformations. For, one can start analyzing chords in just a few lines of Python, as shown below.   from opycleid.musicmonoids import TI_Group_Triads\n\nmy_group = TI_Group_Triads()\nprint (my_group.get_operation( C_M , B_m )) ## ['I6']\nprint (my_group.apply_operation( I5 , E_m )) ## ['Fs_M']    Generalizability : TMT has mainly been applied to the analysis of relations between notes and chords, but it can in fact be applied to any musical object, such as durations, time-spans, rhythms, etc. Opycleid takes a very general approach to TMT by considering  category actions  in   \\mathbf{Rel}  , i.e. faithful functors from a small category to the 2-category   \\mathbf{Rel}   of finite sets and relations between them. The elements of these sets are specified as strings and can represent any musical object.    Customizability : though the usual musical groups and monoids are already implemented in Opycleid, custom monoids can be generated by specifying objects and morphisms. Their definition is made easy by the use of standard Python primitives (dictionaries and lists).    What it is not : to allow the user to define his own category actions, Opycleid implements some routines which can be found in computer algebra systems such as GAP and SageMath. However, Opycleid is focused on musical applications, and is therefore not meant to be as complete as these softwares. In particular, Opycleid does not fully implement category theory (categories, functors, natural transformations, etc.), but focuses on faithful functors to   \\mathbf{Rel}  , which can be more easily implemented.",
            "title": "Guiding principles"
        },
        {
            "location": "/#user-installation",
            "text": "The easiest way to install Opycleid is using  pip :  $ pip install opycleid  Opycleid can also be installed directly from source:  $ python setup.py install",
            "title": "User installation"
        },
        {
            "location": "/#support",
            "text": "Bug reports and features requests (only)  can be posted in  GitHub issues .",
            "title": "Support"
        },
        {
            "location": "/#why-this-name-opycleid",
            "text": "The  ophicleide  is a keyed brass instrument from the 19th century.\nFrom the greek ophis (\u1f44\u03c6\u03b9\u03c2) \"serpent\" (hence the perfect name for a Python library) + kleis (\u03ba\u03bb\u03b5\u03af\u03c2) \"keys\", it means a serpent with keys, the  serpent  being an older instrument it evolved from.   The ophicleide was later superseded by the tuba, which was considered more reliable in terms of tone production.",
            "title": "Why this name, Opycleid ?"
        },
        {
            "location": "/gettingstarted/",
            "text": "A tutorial on Opycleid\n\n\nWe give here a quick tutorial on the major features of Opycleid. Please consult the reference manual for a detailed description of the classes and methods.\n\n\nUsing existing category actions\n\n\nIn simple cases, one would just like to analyze chords, notes, etc. using the groups and monoids commonly used in transformational music theory, such as the transposition/inversion group, also known as the \n T\\text{/}I \n group, or the neo-Riemannian \n \\text{PRL} \n group.\n\n\nOpycleid provides ready-to-use groups and monoids to perform such analysis. Let's take a famous example, first introduced by Richard Cohn (\nRichard Cohn: Maximally Smooth Cycles, Hexatonic Systems, and the Analysis of Late-Romantic Triadic Progressions, Music Analysis, 15(1), pp. 9-40, (1996).\n), namely the second movement of Beethoven's Ninth Symphony at bar 143. This is a progression of 19 major and minor triads, starting with C major, A minor, F major, D minor, B flat major, etc.\n\n\nWe would like to analyze this progression using the \n \\text{PRL} \n group. First, we create a new instance of \nopycleid.musicmonoids.PRL_Group\n.\n\n\nfrom opycleid.musicmonoids import PRL_Group\n\nmy_group = PRL_Group()\n\n\n\n\nThe class \nopycleid.musicmonoids.PRL_Group\n inherits from \nopycleid.categoryaction.MonoidAction\n, which itself inherits from \nopycleid.categoryaction.CategoryAction\n. This latter class is the basis for all category actions, and provides three methods, \nmult\n, \napply_operation\n, and \nget_operation\n for respectively composing musical transformations, applying a musical transformation to a musical element, and getting the possible transformations between two musical elements.\nIn our case, we would like to determine which operation from the \n \\text{PRL} \n group takes C major to A minor, A minor to F major, F major to D minor, and so on. This is achieved in one line in Python by calling the method \nget_operation\n.\n\n\nprint(my_group.get_operation(\nC_M\n,\nA_m\n)) ## prints ['R']\nprint(my_group.get_operation(\nA_m\n,\nF_M\n)) ## prints ['L]\nprint(my_group.get_operation(\nF_M\n,\nD_m\n)) ## prints ['R']\nprint(my_group.get_operation(\nD_m\n,\nBb_M\n)) ## prints ['L']\n\n\n\n\nWe see here that the Beethoven progression is built on a \n R-L \n cycle.\n\n\nTo compare, we could analyze the same progression using the \n T\\text{/}I \n group, which is also implemented in Opycleid.\n\n\nfrom opycleid.musicmonoids import TI_Group_Triads\n\nmy_group = TI_Group_Triads()\n\nprint(my_group.get_operation(\nC_M\n,\nA_m\n)) ## prints ['I4']\nprint(my_group.get_operation(\nA_m\n,\nF_M\n)) ## prints ['I9']\nprint(my_group.get_operation(\nF_M\n,\nD_m\n)) ## prints ['I2']\nprint(my_group.get_operation(\nD_m\n,\nBb_M\n)) ## prints ['I7']\n\n\n\n\nComing back to the \n \\text{PRL} \n group, we could wonder what would yield the transformation \n R \n applied to the G minor triad. This is achieved by calling the method \napply_operation\n.\n\n\nfrom opycleid.musicmonoids import PRL_Group\n\nmy_group = PRL_Group()\nprint(my_group.apply_operation(\nR\n,\nG_m\n)) ## prints ['Bb_M']\n\n\n\n\nFinally, we can multiply operations by calling \nmult\n.\n\n\nfrom opycleid.musicmonoids import PRL_Group\n\nmy_group = PRL_Group()\nprint(my_group.mult(\nRPL\n,\nR\n)) ## prints 'LP'\n\n\n\n\nnote: depending on your configuration, the names of the operations in the monoid might be different, although they represent the same transformation.\n\n\nDefining custom morphisms and category actions\n\n\nIf the ready-to-use monoids and groups provided by Opycleid are not enough, it is possible to create one's own category action for specific musical purposes.\nIn this section, we will see how to build morphisms and generate a category from them.\n\n\nIn our example use case, we would like to study major and augmented triads, and transformations between them. Instead of considering all triads in a single set, we are going to consider two distinct sets: one with the 12 major triads, which we denote by \n X=\\{C_M, C\\sharp_M, D_M, E\\flat_M, E_M, F_M, F\\sharp_M, G_M, G\\sharp_M, A_M, B\\flat_M, B_M\\} \n, and one with the 4 augmented triads, which we denote by \n Y=\\{C_{\\text{aug}}, F_{\\text{aug}}, D_{\\text{aug}}, G_{\\text{aug}}\\} \n.\n\n\nFirst, we need to define these category objects in Opycleid, by instantiating the class \nopycleid.categoryaction.CatObject\n\n\nfrom opycleid.categoryaction import CatObject\n\nX = CatObject(\nX\n,[\nC_M\n,\nCs_M\n,\nD_M\n,\nEb_M\n,\nE_M\n,\n                   \nF_M\n,\nFs_M\n,\nG_M\n,\nGs_M\n,\nA_M\n,\n                   \nBb_M\n,\nB_M\n])\nY = CatObject(\nY\n,[\nC_aug\n,\nF_aug\n,\nD_aug\n,\nG_aug\n])\n\n\n\n\nCaution: all elements should have distinct names.\n\n\nThen, we are going to define some morphisms of interest. The first one is simply the transposition operator acting on the set of the 12 major triads, which send \nC\n major to \nC\\sharp\n major, \nC\\sharp\n major to \nD\n major, and so on. In Opycleid, we need to instantiate the class \nopycleid.categoryaction.CatMorphism\n and define the action of this morphism on its domain.\n\n\nfrom opycleid.categoryaction import CatMorphism\n\n## We create a category morphism with name \nT\n, domain X, and codomain X\nT = CatMorphism(\nT\n,X,X)\nT.set_mapping({\nC_M\n:[\nCs_M\n],\nCs_M\n:[\nD_M\n],\nD_M\n:[\nEb_M\n],\nEb_M\n:[\nE_M\n],\n               \nE_M\n:[\nF_M\n],\nF_M\n:[\nFs_M\n],\nFs_M\n:[\nG_M\n],\nG_M\n:[\nGs_M\n],\n               \nGs_M\n:[\nA_M\n],\nA_M\n:[\nBb_M\n],\nBb_M\n:[\nB_M\n],\nB_M\n:[\nC_M\n]})\n\n\n\n\nAny instance of \nopycleid.categoryaction.CatMorphism\n overloads the \n Python operator in order to denote the action of a morphism on an element of its domain.\nFor example, if we would like to know what is the image of \nF\n major by the morphism \nT\n, we would write the following.\n\n\nprint(T\nF_M\n) ## prints ['Fs_M']\n\n\n\n\nInstances of \nopycleid.categoryaction.CatMorphism\n can be composed if their domain and codomain are compatible. For example, the composition of \nT\n with itself gives, as expected, a transposition operator which moves the root of a major triad by two semitones.\n\n\nT_2 = T*T\nprint(T_2\nF_M\n) ## prints ['G_M']\n\n\n\n\nAs we will see later, there is no need to explicitly calculate all possible compositions of morphisms. Instead, \ngenerators\n will be specified in a category, and Opycleid itself will generate the whole category.\n\n\nSince we want to study transformations between major triads and augmented triads, we are going to define another morphism with domain \nX\n and codomain \nY\n. Observe that, for any major triad, we get an augmented triad if the fifth is raised a semitone higher. This will define our second morphism, and since names can even be unicode strings, we will call it \u540c.\n\n\n## We create a category morphism with name \n\u540c\n, domain X, and codomain Y\nI = CatMorphism(u\n\u540c\n,X,Y)\nI.set_mapping({\nC_M\n:[\nC_aug\n],\nCs_M\n:[\nF_aug\n],\nD_M\n:[\nD_aug\n],\nEb_M\n:[\nG_aug\n],\n               \nE_M\n:[\nC_aug\n],\nF_M\n:[\nF_aug\n],\nFs_M\n:[\nD_aug\n],\nG_M\n:[\nG_aug\n],\n               \nGs_M\n:[\nC_aug\n],\nA_M\n:[\nF_aug\n],\nBb_M\n:[\nD_aug\n],\nB_M\n:[\nG_aug\n]})\n\n\n\n\nCaution: all morphisms (and in particular, generators) in a category should have distinct names.\n\n\nConversely, if one lowers any note of an augmented triad by a semitone, one gets a major triad. Since, there are three possible notes, this defines a relation (and not simply a function) from \nY\n to \nX\n. We will call this morphism \u548c.\n\n\n## We create a category morphism with name \n\u548c\n, domain Y, and codomain X\nJ = CatMorphism(u\n\u548c\n,Y,X)\nJ.set_mapping({\nC_aug\n:[\nC_M\n,\nE_M\n,\nGs_M\n],\n               \nF_aug\n:[\nCs_M\n,\nF_M\n,\nA_M\n],\n               \nD_aug\n:[\nD_M\n,\nFs_M\n,\nBb_M\n],\n               \nG_aug\n:[\nEb_M\n,\nG_M\n,\nB_M\n]})\n\n\n\n\nWe now create the category generated by the two objects \nX\n and \nY\n, and the three morphisms \nT\n, \u540c, and \u548c. For this, we instantiate \nopycleid.categoryaction.CategoryAction\n and specify the objects and the generators.\n\n\nfrom opycleid.categoryaction import CategoryAction\n\nmy_category = CategoryAction()\nmy_category.set_objects([X,Y])\nmy_category.set_generators([T,I,J])\nmy_category.generate_category()\nfor name_f,f in my_category.get_morphisms():\n  print(name_f)\n'''\nThis prints the following list:\nT\nTT\nTTT\nTTTT\nTTTTT\nTTTTTT\nTTTTTTT\nTTTTTTTT\nTTTTTTTTT\nTTTTTTTTTT\nTTTTTTTTTTT\nTTT\u548c\nTT\u548c\nT\u548c\nid_X\nid_Y\n\u540c\n\u540cT\n\u540cTT\n\u540cTTT\n\u540cTTT\u548c\n\u540cTT\u548c\n\u540cT\u548c\n\u548c\n\u548c\u540c\n\u548c\u540cT\n\u548c\u540cTT\n\u548c\u540cTTT\n'''  \n\n\n\n\nDuring the generation process, the names are obtained by concatenation. We can ask Opycleid to rewrite these operations.\n\n\nmy_category.rewrite_operations()\nfor name_f,f in my_category.get_morphisms():\n  print(name_f)\n'''\nThis prints the following list:\n(T^10)\n(T^11)\n(T^2)\n(T^2)\u548c\n(T^3)\n(T^3)\u548c\n(T^4)\n(T^5)\n(T^6)\n(T^7)\n(T^8)\n(T^9)\nT\nT\u548c\nid_X\nid_Y\n\u540c\n\u540c(T^2)\n\u540c(T^2)\u548c\n\u540c(T^3)\n\u540c(T^3)\u548c\n\u540cT\n\u540cT\u548c\n\u548c\n\u548c\u540c\n\u548c\u540c(T^2)\n\u548c\u540c(T^3)\n\u548c\u540cT\n'''\n\n\n\n\nNote:\n the rewriting process of Opycleid is very basic, and only tries to identify repeated consecutive sequences of generators names.\n\n\nOur category is such that\n\n\n\n\nThere are 16 morphisms from \nX\n to \nX\n:\n\n\n12 of the form \nT^p\n with \np=0\\ldots11\n (\nT^0\n being \n\\text{id_X}\n), and\n\n\n4 of the form \nT^p\u548c\u540c\n with \np=0\\ldots3\n (here \u548c\u540c(T^3), \u548c\u540c(T^2), \u548c\u540cT, and \u548c\u540c, since \nT^p\u548c\u540c=\u548c\u540cT^p\n as can be verified directly in Opycleid).\n\n\n\n\n\n\nThere are 4 morphisms from \nY\n to \nY\n:\n\n\nof the form \n\u540cT^p\u548c\n with \np=0\\ldots3\n (\n\u540c\u548c\n being equal to \n\\text{id_Y}\n)\n\n\n\n\n\n\nThere are 4 morphisms from \nX\n to \nY\n:\n\n\nof the form \n\u540cT^p\n with \np=0\\ldots3\n\n\n\n\n\n\n\n\nThere are 4 morphisms from \nY\n to \nX\n:\n\n\nof the form \nT^p\u548c\n with \np=0\\ldots3\n\n\n\n\n\n\n\n\n\n\nNow that our category is generated, we can use it for analyzing transformations between chords.\nFor example, we could ask what are the transformations between \nE\n major and \nA\n major.\n\n\nprint(my_category.get_operation(\nE_M\n,\nA_M\n))\n## Prints ['(T^5)', '\u548c\u540cT']\n\n\n\n\nIndeed we can just transpose \nE\n major by five semitone higher, using \nT^{5}\n, or we can transform \nE\n major to \nC\n augmented using \u540c, then to \nG\\sharp\n major by using \u548c, and finally to \nA\n major by using \nT\n.\n\n\nDefining monoid action morphisms\n\n\nIn the framework of Opycleid, an instance of \nopycleid.categoryaction.CategoryAction\n is a concrete implementation of a faithful functor \n S \\colon \\mathbf{C} \\to \\mathbf{Rel} \n,\nwhere \n \\mathbf{C} \n is a small category, and \n \\mathbf{Rel} \n is the 2-category of finite sets and relations. Such a functor defines a \"context\" for the analysis: in the example above, we worked in the set of the major and minor triads, or in the two distinct sets of major triads and augmented triads.\n\n\nIt is naturally to ask whether an analysis context can be changed. This is the role of \ncategory action morphisms\n. By definition, a morphism between two category actions \n S \\colon \\mathbf{C} \\to \\mathbf{Rel} \n and \n S' \\colon \\mathbf{C'} \\to \\mathbf{Rel} \n is a pair \n (N,\\nu) \n where\n\n\n\n\n\n\n N \n is a functor from \n \\mathbf{C} \n to \n \\mathbf{C'} \n, and\n\n\n\n\n \\nu \n is a \nlax\n natural transformation from \n S \n to \n S'N \n, i.e. for any morphism \n f \\colon X \\to Y \n in \n \\mathbf{C} \n, the relation \n \\nu_Y \\circ S(f) \n is included in the relation \n S'N(f) \\circ \\nu_X \n.\n\n\n\n\nOpycleid provides two classes, \nopycleid.categoryaction.CategoryFunctor\n and \nopycleid.categoryaction.CategoryActionFunctor\n, which define the functor \n N \\colon \\mathbf{C} \\to \\mathbf{C'} \n, and the category action morphism \n (N,\\nu) \n respectively.\n\n\nTo illustrate the notion, consider the \n T\\text{/}I \n group introduced previously. This is an extension \n 1 \\to \\mathbb{Z}_{12} \\to T\\text{/}I \\to \\mathbb{Z}_{2} \\to 1\n, where the homomorphism \n \\pi \\colon T\\text{/}I \\to \\mathbb{Z}_{2} \n sends the transposition operations \nT^p\n to the identity of \n \\mathbb{Z}_{2} \n, whereas the inversion operations \nI^p\n are sent to the non-trivial element of \n \\mathbb{Z}_{2} \n. The group \n \\mathbb{Z}_{2} \n can be made to act on the set of \n\\{major,minor\\}\n of chord types in an obvious manner. We can are then going to build a category action morphism between these two category actions.\n\n\nFirst, we define the group \n \\mathbb{Z}_{2} \n and its action.\n\n\nfrom opycleid.categoryaction import CatObject, CatMorphism, MonoidAction\n\nS = CatObject(\nS\n,[\nmajor\n,\nminor\n])\n\nZ = CatMorphism(\nz\n,S,S)\nZ.set_mapping({\nmajor\n:[\nminor\n],\nminor\n:[\nmajor\n]})\n\nZ2_group = MonoidAction()\nZ2_group.set_objects([S])\nZ2_group.set_generators([Z])\nZ2_group.generate_category()\n\n\n\n\nWe also need to instantiate the \n T\\text{/}I \n group.\n\n\nfrom opycleid.musicmonoids import TI_Group_Triads\n\nG = TI_Group_Triads()\n\n\n\n\nTo define the category action morphism, we need first to define the functor\n\n N \n from the \n T\\text{/}I \n group to the \n \\mathbb{Z}_{2} \n group. This\nis easily done by specifying the images of the generators of the \n T\\text{/}I \n group.\n\n\nfrom opycleid.categoryaction import CategoryFunctor\n\ngenerator_mapping={\nT1\n:\nid_S\n,\nI0\n:\nz\n}\n\nN=CategoryFunctor(G,Z2_group)\nN.set_from_generator_mapping(generator_mapping)\nprint(N.is_valid())\n## Prints True\n\n\n\n\nWe then define the category action morphism. Since both the source and target category actions are in fact monoid actions, the natural transformation \n \\nu \n has\nonly one component for the single object of the \n T\\text{/}I \n group. This component maps any chord to its type (major/minor).\n\n\nelements = G.get_object()[1].get_elements()\nelement_mapping = {}\nfor x in elements:\n    if x[-1]==\nM\n:\n        element_mapping[x]=[\nmajor\n]\n    else:\n        element_mapping[x]=[\nminor\n]\n\n## This is the (only) component of the natural transformation    \neta = CatMorphism(\neta\n,G.get_object()[1],Z2_group.get_object()[1])\neta.set_mapping(element_mapping)\n\n\n\n\nFinally we instantiate a \nopycleid.categoryaction.CategoryActionFunctor\n which defines the category action morphism between the \n T\\text{/}I \n group and the \n \\mathbb{Z}_{2} \n group.\n\n\nfrom opycleid.categoryaction import CategoryActionFunctor\n\n## We assemble everything in the final category action morphism\nNeta = CategoryActionFunctor(G,Z2_group,N,{\n.\n:eta})\n\nprint(Neta.is_valid())\n## Prints True\n\n\n\n\nCategory action morphisms are especially useful for network analysis, which is presented below.\n\n\nKlumpenhouwer and poly-Klumpenhouwer network analysis\n\n\nOpycleid provides the means to perform Klumpenhouwer network (K-Net) and poly-Klumpenhouwer network (PK-Net) analysis.\n\n\nInformally, a K-Net is a directed graph, the vertices of which are labelled with musical objects,\nand the arrows of which are labelled with transformations between them. Arrows are understood to be composable: the label\nof a resulting composite arrow should be equal to the label of the composition of the two original arrows.\n\n\nA K-Net allows one to study the interconnections between different musical elements,\nfor example in the study of the different intervals in the constitutive elements of chords in post-tonal music.\n\n\nRecent research (see \nAlexandre Popoff, Moreno Andreatta, Andr\u00e9e Ehresmann: Relational poly-Klumpenhouwer networks for transformational and voice-leading analysis, Journal of Mathematics and Music, 12:1 (2018), pp. 35-55\n) has proposed to extend the traditional framework of Klumpenhouwer networks. The categorical formalizations of the K-Net notion, leads to the notion of poly-Klumpenhouwer network which corresponds to the data \n (R,S,F,\\phi) \n of\n\n\n\n\na lax functor \n R \\colon \\Delta \\to \\mathbf{Rel} \n, called the \ndiagram action\n,\n\n\na functor \n S \\colon \\mathbf{C} \\to \\mathbf{Rel} \n where \n \\mathbf{C} \n is a finite category called the \ncontext action\n, and\n\n\na category action morphism \n (F, \\phi) \n between them, i.e. a functor \n F \\colon \\Delta \\to \\mathbf{C} \n, and a lax natural transformation \n \\phi \\colon R \\to SF \n (left-total on all components).\n\n\n\n\nThe diagram category action represents the network itself. The context category action is, as its name indicates, the context for analysis, i.e. musical transformations and their action on musical elements. The role of the functor \n F \\colon \\Delta \\to \\mathbf{C} \n is to label the arrows of the network in the diagram category action by morphisms (musical transformations) in the context category action , whereas the role of the natural transformation \n \\phi \n is to label the elements of the network with musical elements from the context.\n\n\nA PK-Net is created in Opycleid by instantiating the class \nopycleid.knetanalysis.PKNet\n using a category action which will serve as the context. For example, let's study the Beethoven progression we have seen above, this time using the \n T\\text{/}I \n group acting on major and minor triads.\n\n\n## G is the previously instantiated TI_Group_Triads (see above)\n\nfrom opycleid.knetanalysis import PKNet\n\nmy_knet = PKNet(G)\n\n\n\n\nAs we will see later, Opycleid allows one to define complex networks by specifying edges and vertices. If one has a list of musical elements, Opycleid can also generate all the possible PK-Nets with a diagram category action in which\n\n\n\n\nobjects are singletons, corresponding to each musical element, and\n\n\nthere is only one morphism between pairs of objects corresponding to the musical transformation taking one element to another.\n\n\n\n\nThese PK-Nets can be obtained by calling the Python generator \nfrom_progression(list_elements)\n, which takes a list of musical elements and yields all possible PK-Nets. Note that an exception will be raised if no transformation exists between musical elements.\n\n\nIn the case of the Beethoven progression, the \n T\\text{/}I \n group acts simply transitively on major and minor triads, so only one PK-Net can be obtained, as shown below.\n\n\nbeethoven_progression = [\nC_M\n,\nA_m\n,\nF_M\n,\nD_m\n,\nBb_M\n]\nfor pknet in my_knet.from_progression(beethoven_progression):\n    print(pknet)\n'''\nX_0 -- I4 --\n X_1\n[['C_M']] -\n [['A_m']]\nX_1 -- I9 --\n X_2\n[['A_m']] -\n [['F_M']]\nX_2 -- I2 --\n X_3\n[['F_M']] -\n [['D_m']]\nX_3 -- I7 --\n X_4\n[['D_m']] -\n [['Bb_M']]\n'''\n\n\n\n\nThe context of a PK-Net can be changed by using a category action morphism, which yields a new PK-Net in the new context category action. This is done by calling the method \nglobal_tansform(cat_action_functor)\n, where \ncat_action_functor\n is an instance of \nopycleid.categoryaction.CategoryActionFunctor\n representing the category action morphism. For example, if we use the monoid action morphism between the \n T\\text{/}I \n group and the \n \\mathbb{Z}_{2} \n group we defined in the previous section, we get the following new PK-net.\n\n\npknet = list(my_knet.from_progression(beethoven_progression))[0]\nnew_pknet = pknet.global_transform(Neta)\nprint(new_pknet)\n'''\nX_0 -- z --\n X_1\n[['major']] -\n [['minor']]\nX_1 -- z --\n X_2\n[['minor']] -\n [['major']]\nX_2 -- z --\n X_3\n[['major']] -\n [['minor']]\nX_3 -- z --\n X_4\n[['minor']] -\n [['major']]\n'''\n\n\n\n\nAs expected, we have transformed our original PK-net describing chords and their transformations to a new PK-net describing \nchord types\n and their transformations.\n\n\nA PK-Net can also be defined from scratch by specifying all the edges and vertices. For example, we would like to define the complex network of pitch classes and their transformations in the \n T\\text{/}I \n group (acting on pitch classes) which is shown below.\n\n\n\n\nThe following code defines the above PK-Net using Opycleid.\n\n\nfrom opycleid.categoryaction import CatObject, CatMorphism\nfrom opycleid.knetanalysis import PKNet\nfrom opycleid.musicmonoids import TI_Group_PC\nG = TI_Group_PC()\n\nX = CatObject(\nX\n,[\npX1\n,\npX2\n])\nY = CatObject(\nY\n,[\npY1\n])\nW = CatObject(\nW\n,[\npW1\n,\npW2\n,\npW3\n])\nZ = CatObject(\nZ\n,[\npZ1\n])\n\nf = CatMorphism(\nf\n,X,W)\nf.set_mapping({\npX1\n:[\npW1\n],\npX2\n:[\npW2\n]})\n\ng = CatMorphism(\ng\n,Y,W)\ng.set_mapping({\npY1\n:[\npW3\n]})\n\nh = CatMorphism(\nh\n,Y,Z)\nh.set_mapping({\npY1\n:[\npZ1\n]})\n\nk = CatMorphism(\nk\n,Z,W)\nk.set_mapping({\npZ1\n:[\npW3\n]})\n\nmy_pknet = PKNet(G)\nmy_pknet.set_edges([f,g,h,k])\nmy_pknet.set_mappings({\nf\n:\nT4\n,\ng\n:\nI3\n,\nh\n:\nI5\n,\nk\n:\nT10\n},\n                  {\npX1\n:[\nD\n],\npX2\n:[\nFs\n],\n                   \npY1\n:[\nCs\n],\n                   \npW1\n:[\nFs\n],\npW2\n:[\nBb\n],\npW3\n:[\nD\n],\n                   \npZ1\n:[\nE\n]\n                  }\n                 )\nprint(my_pknet)\n'''\nX -- T4 --\n W\n[['D'], ['Fs']] -\n [['Fs'], ['Bb'], ['D']]\nY -- I3 --\n W\n[['Cs']] -\n [['Fs'], ['Bb'], ['D']]\nY -- I5 --\n Z\n[['Cs']] -\n [['E']]\nZ -- T10 --\n W\n[['E']] -\n [['Fs'], ['Bb'], ['D']]\n'''\n\n\n\n\nWe define the four sets of the network \n X \n, \n Y \n, \n W \n, and \n Z \n as instances of \nopycleid.categoryaction.CatObject\n.\nThen we define the morphisms between these sets, i.e. the generating arrows/edges of our network, as instances of \nopycleid.categoryaction.CatMorphism\n.\nWe then instantiate a new PK-Net with context category action the \n T\\text{/}I \n group acting on pitch classes, and we set the edges by calling the method \nset_edges\n with argument the list of \nopycleid.categoryaction.CatMorphism\n we just created. The diagram category action will then be created internally. Note that we do not need to explicitly specify the objects as they are automatically deduced from the morphisms. Finally, we define the mapping of edges and elements, by calling \nset_mappings\n with two arguments:\n\n\n\n\nThe first dictionary corresponds to the mapping of the generating edges, i.e. the image of the generating morphisms in the context category action.\n\n\nThe second dictionary corresponds to the mapping of the elements of the objects. The mappings must be left-total, i.e. each element must be related to at least one element in the context category action.\n\n\n\n\nOpycleid will detect non-valid mappings and raise exceptions accordingly.",
            "title": "Tutorial"
        },
        {
            "location": "/gettingstarted/#a-tutorial-on-opycleid",
            "text": "We give here a quick tutorial on the major features of Opycleid. Please consult the reference manual for a detailed description of the classes and methods.",
            "title": "A tutorial on Opycleid"
        },
        {
            "location": "/gettingstarted/#using-existing-category-actions",
            "text": "In simple cases, one would just like to analyze chords, notes, etc. using the groups and monoids commonly used in transformational music theory, such as the transposition/inversion group, also known as the   T\\text{/}I   group, or the neo-Riemannian   \\text{PRL}   group.  Opycleid provides ready-to-use groups and monoids to perform such analysis. Let's take a famous example, first introduced by Richard Cohn ( Richard Cohn: Maximally Smooth Cycles, Hexatonic Systems, and the Analysis of Late-Romantic Triadic Progressions, Music Analysis, 15(1), pp. 9-40, (1996). ), namely the second movement of Beethoven's Ninth Symphony at bar 143. This is a progression of 19 major and minor triads, starting with C major, A minor, F major, D minor, B flat major, etc.  We would like to analyze this progression using the   \\text{PRL}   group. First, we create a new instance of  opycleid.musicmonoids.PRL_Group .  from opycleid.musicmonoids import PRL_Group\n\nmy_group = PRL_Group()  The class  opycleid.musicmonoids.PRL_Group  inherits from  opycleid.categoryaction.MonoidAction , which itself inherits from  opycleid.categoryaction.CategoryAction . This latter class is the basis for all category actions, and provides three methods,  mult ,  apply_operation , and  get_operation  for respectively composing musical transformations, applying a musical transformation to a musical element, and getting the possible transformations between two musical elements.\nIn our case, we would like to determine which operation from the   \\text{PRL}   group takes C major to A minor, A minor to F major, F major to D minor, and so on. This is achieved in one line in Python by calling the method  get_operation .  print(my_group.get_operation( C_M , A_m )) ## prints ['R']\nprint(my_group.get_operation( A_m , F_M )) ## prints ['L]\nprint(my_group.get_operation( F_M , D_m )) ## prints ['R']\nprint(my_group.get_operation( D_m , Bb_M )) ## prints ['L']  We see here that the Beethoven progression is built on a   R-L   cycle.  To compare, we could analyze the same progression using the   T\\text{/}I   group, which is also implemented in Opycleid.  from opycleid.musicmonoids import TI_Group_Triads\n\nmy_group = TI_Group_Triads()\n\nprint(my_group.get_operation( C_M , A_m )) ## prints ['I4']\nprint(my_group.get_operation( A_m , F_M )) ## prints ['I9']\nprint(my_group.get_operation( F_M , D_m )) ## prints ['I2']\nprint(my_group.get_operation( D_m , Bb_M )) ## prints ['I7']  Coming back to the   \\text{PRL}   group, we could wonder what would yield the transformation   R   applied to the G minor triad. This is achieved by calling the method  apply_operation .  from opycleid.musicmonoids import PRL_Group\n\nmy_group = PRL_Group()\nprint(my_group.apply_operation( R , G_m )) ## prints ['Bb_M']  Finally, we can multiply operations by calling  mult .  from opycleid.musicmonoids import PRL_Group\n\nmy_group = PRL_Group()\nprint(my_group.mult( RPL , R )) ## prints 'LP'  note: depending on your configuration, the names of the operations in the monoid might be different, although they represent the same transformation.",
            "title": "Using existing category actions"
        },
        {
            "location": "/gettingstarted/#defining-custom-morphisms-and-category-actions",
            "text": "If the ready-to-use monoids and groups provided by Opycleid are not enough, it is possible to create one's own category action for specific musical purposes.\nIn this section, we will see how to build morphisms and generate a category from them.  In our example use case, we would like to study major and augmented triads, and transformations between them. Instead of considering all triads in a single set, we are going to consider two distinct sets: one with the 12 major triads, which we denote by   X=\\{C_M, C\\sharp_M, D_M, E\\flat_M, E_M, F_M, F\\sharp_M, G_M, G\\sharp_M, A_M, B\\flat_M, B_M\\}  , and one with the 4 augmented triads, which we denote by   Y=\\{C_{\\text{aug}}, F_{\\text{aug}}, D_{\\text{aug}}, G_{\\text{aug}}\\}  .  First, we need to define these category objects in Opycleid, by instantiating the class  opycleid.categoryaction.CatObject  from opycleid.categoryaction import CatObject\n\nX = CatObject( X ,[ C_M , Cs_M , D_M , Eb_M , E_M ,\n                    F_M , Fs_M , G_M , Gs_M , A_M ,\n                    Bb_M , B_M ])\nY = CatObject( Y ,[ C_aug , F_aug , D_aug , G_aug ])  Caution: all elements should have distinct names.  Then, we are going to define some morphisms of interest. The first one is simply the transposition operator acting on the set of the 12 major triads, which send  C  major to  C\\sharp  major,  C\\sharp  major to  D  major, and so on. In Opycleid, we need to instantiate the class  opycleid.categoryaction.CatMorphism  and define the action of this morphism on its domain.  from opycleid.categoryaction import CatMorphism\n\n## We create a category morphism with name  T , domain X, and codomain X\nT = CatMorphism( T ,X,X)\nT.set_mapping({ C_M :[ Cs_M ], Cs_M :[ D_M ], D_M :[ Eb_M ], Eb_M :[ E_M ],\n                E_M :[ F_M ], F_M :[ Fs_M ], Fs_M :[ G_M ], G_M :[ Gs_M ],\n                Gs_M :[ A_M ], A_M :[ Bb_M ], Bb_M :[ B_M ], B_M :[ C_M ]})  Any instance of  opycleid.categoryaction.CatMorphism  overloads the   Python operator in order to denote the action of a morphism on an element of its domain.\nFor example, if we would like to know what is the image of  F  major by the morphism  T , we would write the following.  print(T F_M ) ## prints ['Fs_M']  Instances of  opycleid.categoryaction.CatMorphism  can be composed if their domain and codomain are compatible. For example, the composition of  T  with itself gives, as expected, a transposition operator which moves the root of a major triad by two semitones.  T_2 = T*T\nprint(T_2 F_M ) ## prints ['G_M']  As we will see later, there is no need to explicitly calculate all possible compositions of morphisms. Instead,  generators  will be specified in a category, and Opycleid itself will generate the whole category.  Since we want to study transformations between major triads and augmented triads, we are going to define another morphism with domain  X  and codomain  Y . Observe that, for any major triad, we get an augmented triad if the fifth is raised a semitone higher. This will define our second morphism, and since names can even be unicode strings, we will call it \u540c.  ## We create a category morphism with name  \u540c , domain X, and codomain Y\nI = CatMorphism(u \u540c ,X,Y)\nI.set_mapping({ C_M :[ C_aug ], Cs_M :[ F_aug ], D_M :[ D_aug ], Eb_M :[ G_aug ],\n                E_M :[ C_aug ], F_M :[ F_aug ], Fs_M :[ D_aug ], G_M :[ G_aug ],\n                Gs_M :[ C_aug ], A_M :[ F_aug ], Bb_M :[ D_aug ], B_M :[ G_aug ]})  Caution: all morphisms (and in particular, generators) in a category should have distinct names.  Conversely, if one lowers any note of an augmented triad by a semitone, one gets a major triad. Since, there are three possible notes, this defines a relation (and not simply a function) from  Y  to  X . We will call this morphism \u548c.  ## We create a category morphism with name  \u548c , domain Y, and codomain X\nJ = CatMorphism(u \u548c ,Y,X)\nJ.set_mapping({ C_aug :[ C_M , E_M , Gs_M ],\n                F_aug :[ Cs_M , F_M , A_M ],\n                D_aug :[ D_M , Fs_M , Bb_M ],\n                G_aug :[ Eb_M , G_M , B_M ]})  We now create the category generated by the two objects  X  and  Y , and the three morphisms  T , \u540c, and \u548c. For this, we instantiate  opycleid.categoryaction.CategoryAction  and specify the objects and the generators.  from opycleid.categoryaction import CategoryAction\n\nmy_category = CategoryAction()\nmy_category.set_objects([X,Y])\nmy_category.set_generators([T,I,J])\nmy_category.generate_category()\nfor name_f,f in my_category.get_morphisms():\n  print(name_f)\n'''\nThis prints the following list:\nT\nTT\nTTT\nTTTT\nTTTTT\nTTTTTT\nTTTTTTT\nTTTTTTTT\nTTTTTTTTT\nTTTTTTTTTT\nTTTTTTTTTTT\nTTT\u548c\nTT\u548c\nT\u548c\nid_X\nid_Y\n\u540c\n\u540cT\n\u540cTT\n\u540cTTT\n\u540cTTT\u548c\n\u540cTT\u548c\n\u540cT\u548c\n\u548c\n\u548c\u540c\n\u548c\u540cT\n\u548c\u540cTT\n\u548c\u540cTTT\n'''    During the generation process, the names are obtained by concatenation. We can ask Opycleid to rewrite these operations.  my_category.rewrite_operations()\nfor name_f,f in my_category.get_morphisms():\n  print(name_f)\n'''\nThis prints the following list:\n(T^10)\n(T^11)\n(T^2)\n(T^2)\u548c\n(T^3)\n(T^3)\u548c\n(T^4)\n(T^5)\n(T^6)\n(T^7)\n(T^8)\n(T^9)\nT\nT\u548c\nid_X\nid_Y\n\u540c\n\u540c(T^2)\n\u540c(T^2)\u548c\n\u540c(T^3)\n\u540c(T^3)\u548c\n\u540cT\n\u540cT\u548c\n\u548c\n\u548c\u540c\n\u548c\u540c(T^2)\n\u548c\u540c(T^3)\n\u548c\u540cT\n'''  Note:  the rewriting process of Opycleid is very basic, and only tries to identify repeated consecutive sequences of generators names.  Our category is such that   There are 16 morphisms from  X  to  X :  12 of the form  T^p  with  p=0\\ldots11  ( T^0  being  \\text{id_X} ), and  4 of the form  T^p\u548c\u540c  with  p=0\\ldots3  (here \u548c\u540c(T^3), \u548c\u540c(T^2), \u548c\u540cT, and \u548c\u540c, since  T^p\u548c\u540c=\u548c\u540cT^p  as can be verified directly in Opycleid).    There are 4 morphisms from  Y  to  Y :  of the form  \u540cT^p\u548c  with  p=0\\ldots3  ( \u540c\u548c  being equal to  \\text{id_Y} )    There are 4 morphisms from  X  to  Y :  of the form  \u540cT^p  with  p=0\\ldots3     There are 4 morphisms from  Y  to  X :  of the form  T^p\u548c  with  p=0\\ldots3      Now that our category is generated, we can use it for analyzing transformations between chords.\nFor example, we could ask what are the transformations between  E  major and  A  major.  print(my_category.get_operation( E_M , A_M ))\n## Prints ['(T^5)', '\u548c\u540cT']  Indeed we can just transpose  E  major by five semitone higher, using  T^{5} , or we can transform  E  major to  C  augmented using \u540c, then to  G\\sharp  major by using \u548c, and finally to  A  major by using  T .",
            "title": "Defining custom morphisms and category actions"
        },
        {
            "location": "/gettingstarted/#defining-monoid-action-morphisms",
            "text": "In the framework of Opycleid, an instance of  opycleid.categoryaction.CategoryAction  is a concrete implementation of a faithful functor   S \\colon \\mathbf{C} \\to \\mathbf{Rel}  ,\nwhere   \\mathbf{C}   is a small category, and   \\mathbf{Rel}   is the 2-category of finite sets and relations. Such a functor defines a \"context\" for the analysis: in the example above, we worked in the set of the major and minor triads, or in the two distinct sets of major triads and augmented triads.  It is naturally to ask whether an analysis context can be changed. This is the role of  category action morphisms . By definition, a morphism between two category actions   S \\colon \\mathbf{C} \\to \\mathbf{Rel}   and   S' \\colon \\mathbf{C'} \\to \\mathbf{Rel}   is a pair   (N,\\nu)   where     N   is a functor from   \\mathbf{C}   to   \\mathbf{C'}  , and    \\nu   is a  lax  natural transformation from   S   to   S'N  , i.e. for any morphism   f \\colon X \\to Y   in   \\mathbf{C}  , the relation   \\nu_Y \\circ S(f)   is included in the relation   S'N(f) \\circ \\nu_X  .   Opycleid provides two classes,  opycleid.categoryaction.CategoryFunctor  and  opycleid.categoryaction.CategoryActionFunctor , which define the functor   N \\colon \\mathbf{C} \\to \\mathbf{C'}  , and the category action morphism   (N,\\nu)   respectively.  To illustrate the notion, consider the   T\\text{/}I   group introduced previously. This is an extension   1 \\to \\mathbb{Z}_{12} \\to T\\text{/}I \\to \\mathbb{Z}_{2} \\to 1 , where the homomorphism   \\pi \\colon T\\text{/}I \\to \\mathbb{Z}_{2}   sends the transposition operations  T^p  to the identity of   \\mathbb{Z}_{2}  , whereas the inversion operations  I^p  are sent to the non-trivial element of   \\mathbb{Z}_{2}  . The group   \\mathbb{Z}_{2}   can be made to act on the set of  \\{major,minor\\}  of chord types in an obvious manner. We can are then going to build a category action morphism between these two category actions.  First, we define the group   \\mathbb{Z}_{2}   and its action.  from opycleid.categoryaction import CatObject, CatMorphism, MonoidAction\n\nS = CatObject( S ,[ major , minor ])\n\nZ = CatMorphism( z ,S,S)\nZ.set_mapping({ major :[ minor ], minor :[ major ]})\n\nZ2_group = MonoidAction()\nZ2_group.set_objects([S])\nZ2_group.set_generators([Z])\nZ2_group.generate_category()  We also need to instantiate the   T\\text{/}I   group.  from opycleid.musicmonoids import TI_Group_Triads\n\nG = TI_Group_Triads()  To define the category action morphism, we need first to define the functor  N   from the   T\\text{/}I   group to the   \\mathbb{Z}_{2}   group. This\nis easily done by specifying the images of the generators of the   T\\text{/}I   group.  from opycleid.categoryaction import CategoryFunctor\n\ngenerator_mapping={ T1 : id_S , I0 : z }\n\nN=CategoryFunctor(G,Z2_group)\nN.set_from_generator_mapping(generator_mapping)\nprint(N.is_valid())\n## Prints True  We then define the category action morphism. Since both the source and target category actions are in fact monoid actions, the natural transformation   \\nu   has\nonly one component for the single object of the   T\\text{/}I   group. This component maps any chord to its type (major/minor).  elements = G.get_object()[1].get_elements()\nelement_mapping = {}\nfor x in elements:\n    if x[-1]== M :\n        element_mapping[x]=[ major ]\n    else:\n        element_mapping[x]=[ minor ]\n\n## This is the (only) component of the natural transformation    \neta = CatMorphism( eta ,G.get_object()[1],Z2_group.get_object()[1])\neta.set_mapping(element_mapping)  Finally we instantiate a  opycleid.categoryaction.CategoryActionFunctor  which defines the category action morphism between the   T\\text{/}I   group and the   \\mathbb{Z}_{2}   group.  from opycleid.categoryaction import CategoryActionFunctor\n\n## We assemble everything in the final category action morphism\nNeta = CategoryActionFunctor(G,Z2_group,N,{ . :eta})\n\nprint(Neta.is_valid())\n## Prints True  Category action morphisms are especially useful for network analysis, which is presented below.",
            "title": "Defining monoid action morphisms"
        },
        {
            "location": "/gettingstarted/#klumpenhouwer-and-poly-klumpenhouwer-network-analysis",
            "text": "Opycleid provides the means to perform Klumpenhouwer network (K-Net) and poly-Klumpenhouwer network (PK-Net) analysis.  Informally, a K-Net is a directed graph, the vertices of which are labelled with musical objects,\nand the arrows of which are labelled with transformations between them. Arrows are understood to be composable: the label\nof a resulting composite arrow should be equal to the label of the composition of the two original arrows.  A K-Net allows one to study the interconnections between different musical elements,\nfor example in the study of the different intervals in the constitutive elements of chords in post-tonal music.  Recent research (see  Alexandre Popoff, Moreno Andreatta, Andr\u00e9e Ehresmann: Relational poly-Klumpenhouwer networks for transformational and voice-leading analysis, Journal of Mathematics and Music, 12:1 (2018), pp. 35-55 ) has proposed to extend the traditional framework of Klumpenhouwer networks. The categorical formalizations of the K-Net notion, leads to the notion of poly-Klumpenhouwer network which corresponds to the data   (R,S,F,\\phi)   of   a lax functor   R \\colon \\Delta \\to \\mathbf{Rel}  , called the  diagram action ,  a functor   S \\colon \\mathbf{C} \\to \\mathbf{Rel}   where   \\mathbf{C}   is a finite category called the  context action , and  a category action morphism   (F, \\phi)   between them, i.e. a functor   F \\colon \\Delta \\to \\mathbf{C}  , and a lax natural transformation   \\phi \\colon R \\to SF   (left-total on all components).   The diagram category action represents the network itself. The context category action is, as its name indicates, the context for analysis, i.e. musical transformations and their action on musical elements. The role of the functor   F \\colon \\Delta \\to \\mathbf{C}   is to label the arrows of the network in the diagram category action by morphisms (musical transformations) in the context category action , whereas the role of the natural transformation   \\phi   is to label the elements of the network with musical elements from the context.  A PK-Net is created in Opycleid by instantiating the class  opycleid.knetanalysis.PKNet  using a category action which will serve as the context. For example, let's study the Beethoven progression we have seen above, this time using the   T\\text{/}I   group acting on major and minor triads.  ## G is the previously instantiated TI_Group_Triads (see above)\n\nfrom opycleid.knetanalysis import PKNet\n\nmy_knet = PKNet(G)  As we will see later, Opycleid allows one to define complex networks by specifying edges and vertices. If one has a list of musical elements, Opycleid can also generate all the possible PK-Nets with a diagram category action in which   objects are singletons, corresponding to each musical element, and  there is only one morphism between pairs of objects corresponding to the musical transformation taking one element to another.   These PK-Nets can be obtained by calling the Python generator  from_progression(list_elements) , which takes a list of musical elements and yields all possible PK-Nets. Note that an exception will be raised if no transformation exists between musical elements.  In the case of the Beethoven progression, the   T\\text{/}I   group acts simply transitively on major and minor triads, so only one PK-Net can be obtained, as shown below.  beethoven_progression = [ C_M , A_m , F_M , D_m , Bb_M ]\nfor pknet in my_knet.from_progression(beethoven_progression):\n    print(pknet)\n'''\nX_0 -- I4 --  X_1\n[['C_M']] -  [['A_m']]\nX_1 -- I9 --  X_2\n[['A_m']] -  [['F_M']]\nX_2 -- I2 --  X_3\n[['F_M']] -  [['D_m']]\nX_3 -- I7 --  X_4\n[['D_m']] -  [['Bb_M']]\n'''  The context of a PK-Net can be changed by using a category action morphism, which yields a new PK-Net in the new context category action. This is done by calling the method  global_tansform(cat_action_functor) , where  cat_action_functor  is an instance of  opycleid.categoryaction.CategoryActionFunctor  representing the category action morphism. For example, if we use the monoid action morphism between the   T\\text{/}I   group and the   \\mathbb{Z}_{2}   group we defined in the previous section, we get the following new PK-net.  pknet = list(my_knet.from_progression(beethoven_progression))[0]\nnew_pknet = pknet.global_transform(Neta)\nprint(new_pknet)\n'''\nX_0 -- z --  X_1\n[['major']] -  [['minor']]\nX_1 -- z --  X_2\n[['minor']] -  [['major']]\nX_2 -- z --  X_3\n[['major']] -  [['minor']]\nX_3 -- z --  X_4\n[['minor']] -  [['major']]\n'''  As expected, we have transformed our original PK-net describing chords and their transformations to a new PK-net describing  chord types  and their transformations.  A PK-Net can also be defined from scratch by specifying all the edges and vertices. For example, we would like to define the complex network of pitch classes and their transformations in the   T\\text{/}I   group (acting on pitch classes) which is shown below.   The following code defines the above PK-Net using Opycleid.  from opycleid.categoryaction import CatObject, CatMorphism\nfrom opycleid.knetanalysis import PKNet\nfrom opycleid.musicmonoids import TI_Group_PC\nG = TI_Group_PC()\n\nX = CatObject( X ,[ pX1 , pX2 ])\nY = CatObject( Y ,[ pY1 ])\nW = CatObject( W ,[ pW1 , pW2 , pW3 ])\nZ = CatObject( Z ,[ pZ1 ])\n\nf = CatMorphism( f ,X,W)\nf.set_mapping({ pX1 :[ pW1 ], pX2 :[ pW2 ]})\n\ng = CatMorphism( g ,Y,W)\ng.set_mapping({ pY1 :[ pW3 ]})\n\nh = CatMorphism( h ,Y,Z)\nh.set_mapping({ pY1 :[ pZ1 ]})\n\nk = CatMorphism( k ,Z,W)\nk.set_mapping({ pZ1 :[ pW3 ]})\n\nmy_pknet = PKNet(G)\nmy_pknet.set_edges([f,g,h,k])\nmy_pknet.set_mappings({ f : T4 , g : I3 , h : I5 , k : T10 },\n                  { pX1 :[ D ], pX2 :[ Fs ],\n                    pY1 :[ Cs ],\n                    pW1 :[ Fs ], pW2 :[ Bb ], pW3 :[ D ],\n                    pZ1 :[ E ]\n                  }\n                 )\nprint(my_pknet)\n'''\nX -- T4 --  W\n[['D'], ['Fs']] -  [['Fs'], ['Bb'], ['D']]\nY -- I3 --  W\n[['Cs']] -  [['Fs'], ['Bb'], ['D']]\nY -- I5 --  Z\n[['Cs']] -  [['E']]\nZ -- T10 --  W\n[['E']] -  [['Fs'], ['Bb'], ['D']]\n'''  We define the four sets of the network   X  ,   Y  ,   W  , and   Z   as instances of  opycleid.categoryaction.CatObject .\nThen we define the morphisms between these sets, i.e. the generating arrows/edges of our network, as instances of  opycleid.categoryaction.CatMorphism .\nWe then instantiate a new PK-Net with context category action the   T\\text{/}I   group acting on pitch classes, and we set the edges by calling the method  set_edges  with argument the list of  opycleid.categoryaction.CatMorphism  we just created. The diagram category action will then be created internally. Note that we do not need to explicitly specify the objects as they are automatically deduced from the morphisms. Finally, we define the mapping of edges and elements, by calling  set_mappings  with two arguments:   The first dictionary corresponds to the mapping of the generating edges, i.e. the image of the generating morphisms in the context category action.  The second dictionary corresponds to the mapping of the elements of the objects. The mappings must be left-total, i.e. each element must be related to at least one element in the context category action.   Opycleid will detect non-valid mappings and raise exceptions accordingly.",
            "title": "Klumpenhouwer and poly-Klumpenhouwer network analysis"
        },
        {
            "location": "/categoryaction/",
            "text": "opycleid.categoryaction\n\n\nThis module defines the basic classes needed for building musical transformations.\n\n\nCatObject\n\n\nopycleid.categoryaction.CatObject(name,elements)\n\n\n\n\nDefines a category object, which is simply a named finite set. Elements of the set\nare indexed internally from 0 to len(elements).\n\n\nArguments\n\n\n\n\nname\n: a string used to name the set.\n\n\nelements\n: a list of strings representing the elements of the set.\n\n\n\n\n\n\nMethods\n\n\nget_idx_by_name\n\n\nget_idx_by_name(elem)\n\n\n\n\nReturns the integer index associated with the element \nelem\n. Raises an exception\nif the element cannot be found.\n\n\n\n\nget_name_by_idx\n\n\nget_name_by_idx(idx)\n\n\n\n\nReturns the element associated with the integer index \nidx\n.\n\n\n\n\nget_elements\n\n\nget_elements()\n\n\n\n\nReturns the list of elements contained in this set.\n\n\n\n\nget_cardinality\n\n\nget_cardinality()\n\n\n\n\nReturns the cardinality of the set.\n\n\n\n\nis_in\n\n\nis_in(elem)\n\n\n\n\nReturns \nTrue\n if the element \nelem\n is in the set.\n\n\n\n\nCatMorphism\n\n\nopycleid.categoryaction.CatMorphism(name,source,target)\n\n\n\n\nDefines a category morphism between two category objects. It is defined by its\nsource, its target, and a relation between the source sets and the target sets.\n\n\nArguments\n\n\n\n\nname\n: a string used to name the morphism.\n\n\nsource\n: an instance of \nopycleid.categoryaction.CatObject\n representing the source of the morphism.\n\n\ntarget\n: an instance of \nopycleid.categoryaction.CatObject\n representing the target of the morphism.\n\n\n\n\n\n\nMethods\n\n\nset_name\n\n\nset_name(name)\n\n\n\n\nSets the name of the morphism to \nname\n.\n\n\n\n\nset_to_identity\n\n\nset_to_identity()\n\n\n\n\nIf the source and target are identical, sets the morphism to be the identity on this category object,\ni.e. the relation between the corresponding sets is the identity function.\n\n\n\n\nset_mapping\n\n\nset_mapping(mapping)\n\n\n\n\nDefines the relation between the source sets and the target sets. The argument \nmapping\n should be a dictionary, whose keys are elements in the source set, and whose values are lists of elements in the target set corresponding to the images of the source elements by the given relation.\n\n\n\n\nset_mapping_matrix\n\n\nset_mapping_matrix(matrix)\n\n\n\n\nDefines the relation between the source sets and the target sets using a matrix description. The argument \nmapping\n should be a NumPy array of type \nbool\n. The rows of this matrix corresponds to the elements of the target sets, and the columns corresponds to the elements of the source sets, in both cases indexed as in the corresponding \nCatObject\n. Use only if you are sure about the correspondence between elements and element indices.\n\n\n\n\nget_mapping\n\n\nget_mapping()\n\n\n\n\nReturns the relation defined by this morphism as a dictionary, whose keys are elements in the source set, and whose values are lists of elements in the target set corresponding to the images of the source elements.\n\n\n\n\nget_mapping_matrix\n\n\nget_mapping_matrix()\n\n\n\n\nReturns the relation defined by this morphism as a NumPy array of type \nbool\n.\n\n\n\n\nstr\n\n\nOverloads Python \nstr\n to return a string description of the morphism, including its source, target, and the relation between them.\n\n\n\n\nrshift\n\n\nOverloads the \n operator in order to represent a morphism action.\nA typical use is \nCatMorphism \n elem\n where \nelem\n is a string representing an element in the source set.\nReturns a list of images in the target set.\n\n\n\n\nmul\n\n\nOverloads the \n*\n operator in order to represent morphism composition.\nA typical use is \nCatMorphism_2 * CatMorphism_1\n.\nIf the target of \nCatMorphism_1\n is identical to the source of \nCatMorphism_2\n, this returns the corresponding composite morphism.\nOtherwise, the two morphisms are not composable and an exception will be raised.\n\n\n\n\npow\n\n\nOverloads the \n**\n operator in order to represent morphism iterated multiplication.\nA typical use is \nCatMorphism ** int\n.\nIf \nCatMorphism\n is an endomorphism, i.e. its target is the same object as its source, this returns the corresponding iterated morphism. Otherwise, an exception will be raised.\n\n\n\n\neq\n\n\nOverloads the \n==\n operator in order to check for morphism equality.\nA typical use is \nCatMorphism_2 == CatMorphism_1\n.\nReturns \nTrue\n if the sources, targets, and relations of both morphisms are equal.\n\n\n\n\nle\n\n\nOverloads the \n=\n operator in order to check for morphism inclusion.\nA typical use is \nCatMorphism_2 \n= CatMorphism_1\n.\nReturns \nTrue\n if the sources, and targets of both morphisms are equal, and if the relation of \nCatMorphism_2\n is equal or included in the relation of \nCatMorphism_1\n.\n\n\n\n\nlt\n\n\nOverloads the \n operator in order to check for strict morphism inclusion.\nA typical use is \nCatMorphism_2 \n CatMorphism_1\n.\nReturns \nTrue\n if the sources, and targets of both morphisms are equal, and if the relation of \nCatMorphism_2\n is non-trivially included in the relation of \nCatMorphism_1\n (i.e. it is included but not equal).\n\n\n\n\nCategoryAction\n\n\nopycleid.categoryaction.CategoryAction()\n\n\n\n\nDefines a category action object, i.e. a faithful functor \n F \\colon \\mathbf{C} \\to \\mathbf{Rel} \n,\nwhere \n \\mathbf{C} \n is a small category, and \n \\mathbf{Rel} \n is the 2-category of finite sets and relations.\nInstances of this class store internally\n\n\n\n\na dictionary of \nopycleid.categoryaction.CatObject\n instances, indexed by their name\n\n\na dictionary of \nopycleid.categoryaction.CatMorphism\n instances, indexed by their name, corresponding to the generators of the category,\n\n\na dictionary of \nopycleid.categoryaction.CatMorphism\n instances, indexed by their name, corresponding to all the operations of the category.\n\n\n\n\n\n\nMethods\n\n\nset_objects\n\n\nset_objects(list_objects)\n\n\n\n\nThe argument \nlist_objects\n should be a list of \nopycleid.categoryaction.CatObject\n instances. Calling this method stores the \nCatObject\n instances\nin the internal dictionary, and resets the generators and operations of the category.\nThe objects must have distinct elements; an exception will be raised if this is not the case.\n\n\n\n\nget_objects()\n\n\nget_objects()\n\n\n\n\nReturns the objects in this category, as a list of tuples \n(String,CatObject)\n, where the \nCatObject\n instance is an object of the category, and \nString\n corresponds to its name.\n\n\n\n\nset_generators\n\n\nset_generators(list_morphisms)\n\n\n\n\nThe argument \nlist_morphisms\n should be a list of \nopycleid.categoryaction.CatMorphism\n instances with distinct names (an exception will be raised if this is not the case). Calling this method will erase the previous internal dictionaries of generators and morphisms (but not objects). The internal dictionary of generators is then updated with the instances of \nlist_morphisms\n.\n\n\n\n\ngenerate_category\n\n\ngenerate_category()\n\n\n\n\nGenerates the category from the internal dictionary of generators. This means that for any operation \n f \n and any generator \n g \n of this category, the composite operation \n g \\circ f \n will be added to the internal dictionary of operations, if not already present, until the generation is complete.\n\n\n\n\nget_generators()\n\n\nget_generators()\n\n\n\n\nReturns the objects in this category, as a list of tuples \n(String,CatMorphism)\n, where the \nCatMorphism\n instance is a generator morphism of the category, and \nString\n corresponds to its name.\n\n\n\n\nget_morphisms()\n\n\nget_morphisms()\n\n\n\n\nReturns the objects in this category, as a list of tuples \n(String,CatMorphism)\n, where the \nCatMorphism\n instance is a morphism of the category, and \nString\n corresponds to its name.\n\n\n\n\nrename_operation\n\n\nrename_operation(name,new_name)\n\n\n\n\nThe arguments \nname\n and \nnew_name\n are the name of a category operation, and the specified new name respectively.\nRenames an operation in the category.\n\n\n\n\nrewrite_operations\n\n\nrewrite_operations()\n\n\n\n\nRewrite/simplify operation names in the category. Calling this method will examine all operation names, trying to identify repeated instances of the names of the generators, and simplifying them to \"([name]^p)\" where p is the corresponding power.\n\n\n\n\nmult\n\n\nmult(operation_2,operation_1)\n\n\n\n\nThe arguments \noperation_2\n and \noperation_1\n are the names of category operations.\nReturns the name of the composite operation \n \\text{operation_2} \\circ \\text{operation_1} \n if present.\n\n\n\n\napply_operation\n\n\napply_operation(name,elem)\n\n\n\n\nThe argument \nname\n is the name of a category operation, and the argument \nelem\n is an element in its source set.\nReturns the images of \nelem\n by the category operation with name \nname\n.\n\n\n\n\nget_operation\n\n\nget_operation(elem_1,elem_2)\n\n\n\n\nThe arguments \nelem_1\n and \nelem_2\n are elements in the objects of the category.\nReturns all the operations \nf\n in the category such that \nelem_2\n is the image of \nelem_1\n by \n f \n.\n\n\n\n\nget_description\n\n\nget_description(name)\n\n\n\n\nReturns a string description of the morphism with name \nname\n.\n\n\n\n\nget_automorphisms\n\n\nget_automorphisms()\n\n\n\n\nComputes the automorphisms of the category \n \\mathbf{C} \n of the current category action \n F \\colon \\mathbf{C} \\to \\mathbf{Rel} \n.\nReturns a list of \nCategoryFunctor\n instances, each one corresponding to an automorphism \n \\mathbf{C} \\to \\mathbf{C}\n.\n\n\nIn the current implementation, calling this method enumerates every mapping from the generators to the morphisms. It is not optimized, and therefore should not be used for large category actions.\n\n\n\n\nMonoidAction\n\n\nopycleid.categoryaction.MonoidAction()\n\n\n\n\nDefines a monoid action object, i.e. a faithful functor \n F \\colon \\mathbf{C} \\to \\mathbf{Rel} \n,\nwhere \n \\mathbf{C} \n is a single-object category, and \n \\mathbf{Rel} \n is the 2-category of finite sets and relations.\nThis class inherits from \nopycleid.categoryaction.CategoryAction\n, and implements methods specific to the case of monoids and groups.\n\n\n\n\nMethods\n\n\nset_objects\n\n\nset_objects(list_objects)\n\n\n\n\nThis method is the same as the one in \nopycleid.categoryaction.CategoryAction\n, except that only a single instance of \nopycleid.categoryaction.CatObject\n is allowed in the list \nlist_objects\n.\n\n\n\n\nget_object\n\n\nget_object()\n\n\n\n\nReturns the single object of the monoid action as a tuple \n(String,CatObject)\n, where the \nCatObject\n instance is the single object of the monoid, and \nString\n corresponds to its name. This is equivalent to \nget_objects()[0]\n.\n\n\n\n\nis_simplytransitive\n\n\nis_simplytransitive()\n\n\n\n\nChecks if the monoid acts simply transitively. Return \nTrue\n if it does.\n\n\n\n\nelement_Rclass\n\n\nelement_Rclass(operation)\n\n\n\n\nThe argument \noperation\n should be the name of an operation in the monoid. Generates the R class for the specified operation.\n\n\nNote\n: for a given morphism \n f \n, i.e. the R class is the set of all \n g \n such that we have \n f \\mathcal{R} g \n  for Green's \n \\mathcal{R}\n relation, i.e. \n f \\mathcal{R} g \n if \n fS = gS \n where \nS\n is the monoid.\n\n\n\n\nelement_Lclass\n\n\nelement_Lclass(operation)\n\n\n\n\nThe argument \noperation\n should be the name of an operation in the monoid. Generates the L class for the specified operation.\n\n\nNote\n: for a given morphism \n f \n, i.e. the L class is the set of all \n g \n such that we have \n f \\mathcal{L} g \n  for Green's \n \\mathcal{L}\n relation, i.e. \n f \\mathcal{L} g \n if \n Sf = Sg \n where \nS\n is the monoid.\n\n\n\n\nget_Rclasses\n\n\nget_Rclasses()\n\n\n\n\nReturns all R classes in this monoid as a list of lists, each list being an R class.\n\n\n\n\nget_Lclasses\n\n\nget_Lclasses()\n\n\n\n\nReturns all L classes in this monoid as a list of lists, each list being an L class.\n\n\n\n\nget_leftIdeals\n\n\nget_leftIdeals()\n\n\n\n\nReturns all left ideals in this monoid as a list of lists, each list being a left ideal.\nA left ideal is a subset \nX\n of the monoid, such that for any operation \nm\n in the monoid, \nmX\n is included in \nX\n.\n\n\n\n\nget_rightIdeals\n\n\nget_rightIdeals()\n\n\n\n\nReturns all right ideals in this monoid as a list of lists, each list being a right ideal.\nA right ideal is a subset \nX\n of the monoid, such that for any operation \nm\n in the monoid, \nXm\n is included in \nX\n.\n\n\n\n\nis_leftIdeal\n\n\nis_leftIdeal(S)\n\n\n\n\nReturns \nTrue\n if the subset \nS\n is a left ideal in the monoid.\n\n\n\n\nis_rightIdeal\n\n\nis_rightIdeal(S)\n\n\n\n\nReturns \nTrue\n if the subset \nS\n is a right ideal in the monoid.\n\n\n\n\nCategoryFunctor\n\n\nopycleid.categoryaction.CategoryFunctor(cat_action_source,cat_action_target)\n\n\n\n\nA \nCategoryFunctor\n instance represents a functor \n N \\colon \\mathbf{C} \\to \\mathbf{C}' \n between the categories \n \\mathbf{C} \n and \n \\mathbf{C}' \n corresponding to the category actions \n S \\colon \\mathbf{C} \\to \\mathbf{Rel} \n and \n S' \\colon \\mathbf{C'} \\to \\mathbf{Rel} \n.\n\n\nIt is instantiated by specifying two instances \ncat_action_source\n and \ncat_action_target\n of \nopycleid.categoryaction.CategoryAction\n, i.e. the domain and codomain of the functor \n N \\colon \\mathbf{C} \\to \\mathbf{C}' \n.\n\n\n\n\nMethods\n\n\nset_fullmapping\n\n\nset_fullmapping(object_mapping,morphism_mapping)\n\n\n\n\nSets the mapping of morphisms and objects between the domain and codomain category actions. The method checks that the given mappings are\nvalid, i.e. that\n\n\n\n\nfor every morphism \n f \\colon X \\to Y \n of \n \\mathbf{C} \n, the image morphism by \n N \n is a morphism from \n N(X) \n to \n N(Y) \n.\n\n\nfor every morphisms \n f,g \n of \n \\mathbf{C} \n, we have \n N(g \\circ f) = N(g) \\circ N(f) \n.\n\n\n\n\nThe arguments of this method are as follows.\n\n\n\n\nobject_mapping\n is a dictionary, the keys of which are object names in the source category action, the values of which are object names in the target category action.\n\n\nmorphism_mapping\n is a dictionary, the keys of which are morphism names in the source category action, the values of which are morphism names in the target category action.\n\n\n\n\nReturns \nTrue\n if the given mappings are valid, \nFalse\n otherwise.\n\n\n\n\nset_fullmapping\n\n\nset_from_generator_mapping(gen_mapping)\n\n\n\n\nSets the mapping of morphisms and objects between the domain and codomain category actions from a mapping of the generators of the source category action.\nThe argument \ngen_mapping\n is a dictionary, the keys of which are generator names in the source category action, the values of which are morphism names in the target category action. The full mapping of objects and morphisms is deduced from the generator mapping.\nThe method checks that the given generator mapping is valid, and returns \nTrue\n if this is case, \nFalse\n otherwise.\n\n\n\n\nget_image_object\n\n\nget_image_object(object_name)\n\n\n\n\nReturns the image of an object of the source category action by the category functor. The argument \nobject_name\n is a string representing the name of an object in the source category of this functor. A string representing the image of \nobject_name\n in the target category action of this functor is returned.\n\n\n\n\nget_image_morphism\n\n\nget_image_morphism(morphism_name)\n\n\n\n\nReturns the image of a morphism of the source category action by the category functor. The argument \nmorphism_name\n is a string representing the name of a morphism in the source category of this functor. A string representing the image of \nmorphism_name\n in the target category action of this functor is returned.\n\n\n\n\nget_object_mapping\n\n\nget_object_mapping()\n\n\n\n\nReturns the full mapping of objects by the category functor as a dictionary.\n\n\n\n\nget_morphism_mapping\n\n\nget_morphism_mapping()\n\n\n\n\nReturns the full mapping of morphisms by the category functor as a dictionary.\n\n\n--\n\n\nis_valid\n\n\nis_valid()\n\n\n\n\nChecks if the category functor is a valid one, returns \nTrue\n if this is case, \nFalse\n otherwise.\n\n\n--\n\n\nis_automorphism\n\n\nis_automorphism()\n\n\n\n\nChecks if the category functor is an automorphism, i.e. the source and target categories are identical, and the mapping of objects and morphisms is bijective. Returns \nTrue\n if this is case, \nFalse\n otherwise.\n\n\n\n\nmul\n\n\nOverloads the \n*\n operator in order to represent category functor composition.\nA typical use is \nCategoryFunctor_2 * CategoryFunctor_1\n.\nIf the target category of \nCategoryFunctor_1\n is identical to the source category of \nCategoryFunctor_2\n, this returns the corresponding composite functor.\nOtherwise, the two functors are not composable and an exception will be raised.\n\n\n\n\neq\n\n\nOverloads the \n==\n operator in order to represent category functor equality.\nA typical use is \nCategoryFunctor_2 == CategoryFunctor_1\n.\nReturns \nTrue\n if this the mapping of objects and morphisms are identical, \nFalse\n otherwise.\n\n\n\n\nCategoryActionFunctor\n\n\nopycleid.categoryaction.CategoryActionFunctor(cat_action_source,cat_action_target,cat_functor,nat_transform)\n\n\n\n\nA \nCategoryActionFunctor\n instance represents a morphism between two category actions \n F \\colon \\mathbf{C} \\to \\mathbf{Rel} \n and \n F' \\colon \\mathbf{C'} \\to \\mathbf{Rel} \n. Such a morphism is the data of a pair \n (N,\\nu) \n where\n\n\n\n\n\n\n N \n is a functor from \n \\mathbf{C} \n to \n \\mathbf{C'} \n, and\n\n\n\n\n \\nu \n is a lax natural transformation from \n S \n to \n S'N \n.\n\n\n\n\nIt is instantiated by specifying\n\n\n\n\ntwo instances \ncat_action_source\n and \ncat_action_target\n of \nopycleid.categoryaction.CategoryAction\n, i.e. the domain and codomain of the functor \n N \\colon \\mathbf{C} \\to \\mathbf{C}' \n,\n\n\nan instance \ncat_functor\n of \nopycleid.categoryaction.CategoryFunctor\n representing the functor \n N \\colon \\mathbf{C} \\to \\mathbf{C}' \n, and\n\n\na dictionary \nnat_transform\n representing the natural transformation \n \\nu \\colon S \\to S'N \n. The keys of this dictionary are object names in the source category action \n S \\colon \\mathbf{C} \\to \\mathbf{Rel} \n, the values are instances of \nopycleid.categoryactionCatMorphism\n from the object to their images.\n\n\n\n\n\n\nMethods\n\n\nis_valid\n\n\nis_valid()\n\n\n\n\nChecks if the category action functor is a valid one, i.e. that\n\n\n\n\nthe functor \n N \\mathbf{C} \\to \\mathbf{C'} \n is a valid one, and\n\n\nthe lax natural transformation \n \\nu \n is valid, i.e. that for any morphism \n f \\colon X \\to Y \n in the source category action, the relation \n \\nu_Y \\circ S(f) \n is included in the relation \n S'N(f) \\circ \\nu_X \n.\n\n\n\n\nReturns \nTrue\n if the category action functor is a valid one, \nFalse\n otherwise.\n\n\n\n\nmul\n\n\nOverloads the \n*\n operator in order to represent category action functor composition.\nA typical use is \nCategoryActionFunctor_2 * CategoryActionFunctor_1\n.\nIf the target category action of \nCategoryActionFunctor_1\n is identical to the source category action of \nCategoryActionFunctor_2\n, this returns the corresponding composite category action functor, corresponding to the data of \n (N_2 \\circ N_1,N_1\\nu_2 \\circ \\nu_1) \n\nOtherwise, the two category action functors are not composable and an exception will be raised.\n\n\n\n\neq\n\n\nOverloads the \n==\n operator in order to represent category action functor equality.\nA typical use is \nCategoryActionFunctor_2 == CategoryActionFunctor_1\n.\nReturns \nTrue\n if this both the category functor and the natural transformation are equal, \nFalse\n otherwise.",
            "title": "opycleid.categoryaction"
        },
        {
            "location": "/categoryaction/#opycleidcategoryaction",
            "text": "This module defines the basic classes needed for building musical transformations.",
            "title": "opycleid.categoryaction"
        },
        {
            "location": "/categoryaction/#catobject",
            "text": "opycleid.categoryaction.CatObject(name,elements)  Defines a category object, which is simply a named finite set. Elements of the set\nare indexed internally from 0 to len(elements).",
            "title": "CatObject"
        },
        {
            "location": "/categoryaction/#arguments",
            "text": "name : a string used to name the set.  elements : a list of strings representing the elements of the set.",
            "title": "Arguments"
        },
        {
            "location": "/categoryaction/#methods",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/categoryaction/#get_idx_by_name",
            "text": "get_idx_by_name(elem)  Returns the integer index associated with the element  elem . Raises an exception\nif the element cannot be found.",
            "title": "get_idx_by_name"
        },
        {
            "location": "/categoryaction/#get_name_by_idx",
            "text": "get_name_by_idx(idx)  Returns the element associated with the integer index  idx .",
            "title": "get_name_by_idx"
        },
        {
            "location": "/categoryaction/#get_elements",
            "text": "get_elements()  Returns the list of elements contained in this set.",
            "title": "get_elements"
        },
        {
            "location": "/categoryaction/#get_cardinality",
            "text": "get_cardinality()  Returns the cardinality of the set.",
            "title": "get_cardinality"
        },
        {
            "location": "/categoryaction/#is_in",
            "text": "is_in(elem)  Returns  True  if the element  elem  is in the set.",
            "title": "is_in"
        },
        {
            "location": "/categoryaction/#catmorphism",
            "text": "opycleid.categoryaction.CatMorphism(name,source,target)  Defines a category morphism between two category objects. It is defined by its\nsource, its target, and a relation between the source sets and the target sets.",
            "title": "CatMorphism"
        },
        {
            "location": "/categoryaction/#arguments_1",
            "text": "name : a string used to name the morphism.  source : an instance of  opycleid.categoryaction.CatObject  representing the source of the morphism.  target : an instance of  opycleid.categoryaction.CatObject  representing the target of the morphism.",
            "title": "Arguments"
        },
        {
            "location": "/categoryaction/#methods_1",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/categoryaction/#set_name",
            "text": "set_name(name)  Sets the name of the morphism to  name .",
            "title": "set_name"
        },
        {
            "location": "/categoryaction/#set_to_identity",
            "text": "set_to_identity()  If the source and target are identical, sets the morphism to be the identity on this category object,\ni.e. the relation between the corresponding sets is the identity function.",
            "title": "set_to_identity"
        },
        {
            "location": "/categoryaction/#set_mapping",
            "text": "set_mapping(mapping)  Defines the relation between the source sets and the target sets. The argument  mapping  should be a dictionary, whose keys are elements in the source set, and whose values are lists of elements in the target set corresponding to the images of the source elements by the given relation.",
            "title": "set_mapping"
        },
        {
            "location": "/categoryaction/#set_mapping_matrix",
            "text": "set_mapping_matrix(matrix)  Defines the relation between the source sets and the target sets using a matrix description. The argument  mapping  should be a NumPy array of type  bool . The rows of this matrix corresponds to the elements of the target sets, and the columns corresponds to the elements of the source sets, in both cases indexed as in the corresponding  CatObject . Use only if you are sure about the correspondence between elements and element indices.",
            "title": "set_mapping_matrix"
        },
        {
            "location": "/categoryaction/#get_mapping",
            "text": "get_mapping()  Returns the relation defined by this morphism as a dictionary, whose keys are elements in the source set, and whose values are lists of elements in the target set corresponding to the images of the source elements.",
            "title": "get_mapping"
        },
        {
            "location": "/categoryaction/#get_mapping_matrix",
            "text": "get_mapping_matrix()  Returns the relation defined by this morphism as a NumPy array of type  bool .",
            "title": "get_mapping_matrix"
        },
        {
            "location": "/categoryaction/#str",
            "text": "Overloads Python  str  to return a string description of the morphism, including its source, target, and the relation between them.",
            "title": "str"
        },
        {
            "location": "/categoryaction/#rshift",
            "text": "Overloads the   operator in order to represent a morphism action.\nA typical use is  CatMorphism   elem  where  elem  is a string representing an element in the source set.\nReturns a list of images in the target set.",
            "title": "rshift"
        },
        {
            "location": "/categoryaction/#mul",
            "text": "Overloads the  *  operator in order to represent morphism composition.\nA typical use is  CatMorphism_2 * CatMorphism_1 .\nIf the target of  CatMorphism_1  is identical to the source of  CatMorphism_2 , this returns the corresponding composite morphism.\nOtherwise, the two morphisms are not composable and an exception will be raised.",
            "title": "mul"
        },
        {
            "location": "/categoryaction/#pow",
            "text": "Overloads the  **  operator in order to represent morphism iterated multiplication.\nA typical use is  CatMorphism ** int .\nIf  CatMorphism  is an endomorphism, i.e. its target is the same object as its source, this returns the corresponding iterated morphism. Otherwise, an exception will be raised.",
            "title": "pow"
        },
        {
            "location": "/categoryaction/#eq",
            "text": "Overloads the  ==  operator in order to check for morphism equality.\nA typical use is  CatMorphism_2 == CatMorphism_1 .\nReturns  True  if the sources, targets, and relations of both morphisms are equal.",
            "title": "eq"
        },
        {
            "location": "/categoryaction/#le",
            "text": "Overloads the  =  operator in order to check for morphism inclusion.\nA typical use is  CatMorphism_2  = CatMorphism_1 .\nReturns  True  if the sources, and targets of both morphisms are equal, and if the relation of  CatMorphism_2  is equal or included in the relation of  CatMorphism_1 .",
            "title": "le"
        },
        {
            "location": "/categoryaction/#lt",
            "text": "Overloads the   operator in order to check for strict morphism inclusion.\nA typical use is  CatMorphism_2   CatMorphism_1 .\nReturns  True  if the sources, and targets of both morphisms are equal, and if the relation of  CatMorphism_2  is non-trivially included in the relation of  CatMorphism_1  (i.e. it is included but not equal).",
            "title": "lt"
        },
        {
            "location": "/categoryaction/#categoryaction",
            "text": "opycleid.categoryaction.CategoryAction()  Defines a category action object, i.e. a faithful functor   F \\colon \\mathbf{C} \\to \\mathbf{Rel}  ,\nwhere   \\mathbf{C}   is a small category, and   \\mathbf{Rel}   is the 2-category of finite sets and relations.\nInstances of this class store internally   a dictionary of  opycleid.categoryaction.CatObject  instances, indexed by their name  a dictionary of  opycleid.categoryaction.CatMorphism  instances, indexed by their name, corresponding to the generators of the category,  a dictionary of  opycleid.categoryaction.CatMorphism  instances, indexed by their name, corresponding to all the operations of the category.",
            "title": "CategoryAction"
        },
        {
            "location": "/categoryaction/#methods_2",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/categoryaction/#set_objects",
            "text": "set_objects(list_objects)  The argument  list_objects  should be a list of  opycleid.categoryaction.CatObject  instances. Calling this method stores the  CatObject  instances\nin the internal dictionary, and resets the generators and operations of the category.\nThe objects must have distinct elements; an exception will be raised if this is not the case.",
            "title": "set_objects"
        },
        {
            "location": "/categoryaction/#get_objects",
            "text": "get_objects()  Returns the objects in this category, as a list of tuples  (String,CatObject) , where the  CatObject  instance is an object of the category, and  String  corresponds to its name.",
            "title": "get_objects()"
        },
        {
            "location": "/categoryaction/#set_generators",
            "text": "set_generators(list_morphisms)  The argument  list_morphisms  should be a list of  opycleid.categoryaction.CatMorphism  instances with distinct names (an exception will be raised if this is not the case). Calling this method will erase the previous internal dictionaries of generators and morphisms (but not objects). The internal dictionary of generators is then updated with the instances of  list_morphisms .",
            "title": "set_generators"
        },
        {
            "location": "/categoryaction/#generate_category",
            "text": "generate_category()  Generates the category from the internal dictionary of generators. This means that for any operation   f   and any generator   g   of this category, the composite operation   g \\circ f   will be added to the internal dictionary of operations, if not already present, until the generation is complete.",
            "title": "generate_category"
        },
        {
            "location": "/categoryaction/#get_generators",
            "text": "get_generators()  Returns the objects in this category, as a list of tuples  (String,CatMorphism) , where the  CatMorphism  instance is a generator morphism of the category, and  String  corresponds to its name.",
            "title": "get_generators()"
        },
        {
            "location": "/categoryaction/#get_morphisms",
            "text": "get_morphisms()  Returns the objects in this category, as a list of tuples  (String,CatMorphism) , where the  CatMorphism  instance is a morphism of the category, and  String  corresponds to its name.",
            "title": "get_morphisms()"
        },
        {
            "location": "/categoryaction/#rename_operation",
            "text": "rename_operation(name,new_name)  The arguments  name  and  new_name  are the name of a category operation, and the specified new name respectively.\nRenames an operation in the category.",
            "title": "rename_operation"
        },
        {
            "location": "/categoryaction/#rewrite_operations",
            "text": "rewrite_operations()  Rewrite/simplify operation names in the category. Calling this method will examine all operation names, trying to identify repeated instances of the names of the generators, and simplifying them to \"([name]^p)\" where p is the corresponding power.",
            "title": "rewrite_operations"
        },
        {
            "location": "/categoryaction/#mult",
            "text": "mult(operation_2,operation_1)  The arguments  operation_2  and  operation_1  are the names of category operations.\nReturns the name of the composite operation   \\text{operation_2} \\circ \\text{operation_1}   if present.",
            "title": "mult"
        },
        {
            "location": "/categoryaction/#apply_operation",
            "text": "apply_operation(name,elem)  The argument  name  is the name of a category operation, and the argument  elem  is an element in its source set.\nReturns the images of  elem  by the category operation with name  name .",
            "title": "apply_operation"
        },
        {
            "location": "/categoryaction/#get_operation",
            "text": "get_operation(elem_1,elem_2)  The arguments  elem_1  and  elem_2  are elements in the objects of the category.\nReturns all the operations  f  in the category such that  elem_2  is the image of  elem_1  by   f  .",
            "title": "get_operation"
        },
        {
            "location": "/categoryaction/#get_description",
            "text": "get_description(name)  Returns a string description of the morphism with name  name .",
            "title": "get_description"
        },
        {
            "location": "/categoryaction/#get_automorphisms",
            "text": "get_automorphisms()  Computes the automorphisms of the category   \\mathbf{C}   of the current category action   F \\colon \\mathbf{C} \\to \\mathbf{Rel}  .\nReturns a list of  CategoryFunctor  instances, each one corresponding to an automorphism   \\mathbf{C} \\to \\mathbf{C} .  In the current implementation, calling this method enumerates every mapping from the generators to the morphisms. It is not optimized, and therefore should not be used for large category actions.",
            "title": "get_automorphisms"
        },
        {
            "location": "/categoryaction/#monoidaction",
            "text": "opycleid.categoryaction.MonoidAction()  Defines a monoid action object, i.e. a faithful functor   F \\colon \\mathbf{C} \\to \\mathbf{Rel}  ,\nwhere   \\mathbf{C}   is a single-object category, and   \\mathbf{Rel}   is the 2-category of finite sets and relations.\nThis class inherits from  opycleid.categoryaction.CategoryAction , and implements methods specific to the case of monoids and groups.",
            "title": "MonoidAction"
        },
        {
            "location": "/categoryaction/#methods_3",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/categoryaction/#set_objects_1",
            "text": "set_objects(list_objects)  This method is the same as the one in  opycleid.categoryaction.CategoryAction , except that only a single instance of  opycleid.categoryaction.CatObject  is allowed in the list  list_objects .",
            "title": "set_objects"
        },
        {
            "location": "/categoryaction/#get_object",
            "text": "get_object()  Returns the single object of the monoid action as a tuple  (String,CatObject) , where the  CatObject  instance is the single object of the monoid, and  String  corresponds to its name. This is equivalent to  get_objects()[0] .",
            "title": "get_object"
        },
        {
            "location": "/categoryaction/#is_simplytransitive",
            "text": "is_simplytransitive()  Checks if the monoid acts simply transitively. Return  True  if it does.",
            "title": "is_simplytransitive"
        },
        {
            "location": "/categoryaction/#element_rclass",
            "text": "element_Rclass(operation)  The argument  operation  should be the name of an operation in the monoid. Generates the R class for the specified operation.  Note : for a given morphism   f  , i.e. the R class is the set of all   g   such that we have   f \\mathcal{R} g    for Green's   \\mathcal{R}  relation, i.e.   f \\mathcal{R} g   if   fS = gS   where  S  is the monoid.",
            "title": "element_Rclass"
        },
        {
            "location": "/categoryaction/#element_lclass",
            "text": "element_Lclass(operation)  The argument  operation  should be the name of an operation in the monoid. Generates the L class for the specified operation.  Note : for a given morphism   f  , i.e. the L class is the set of all   g   such that we have   f \\mathcal{L} g    for Green's   \\mathcal{L}  relation, i.e.   f \\mathcal{L} g   if   Sf = Sg   where  S  is the monoid.",
            "title": "element_Lclass"
        },
        {
            "location": "/categoryaction/#get_rclasses",
            "text": "get_Rclasses()  Returns all R classes in this monoid as a list of lists, each list being an R class.",
            "title": "get_Rclasses"
        },
        {
            "location": "/categoryaction/#get_lclasses",
            "text": "get_Lclasses()  Returns all L classes in this monoid as a list of lists, each list being an L class.",
            "title": "get_Lclasses"
        },
        {
            "location": "/categoryaction/#get_leftideals",
            "text": "get_leftIdeals()  Returns all left ideals in this monoid as a list of lists, each list being a left ideal.\nA left ideal is a subset  X  of the monoid, such that for any operation  m  in the monoid,  mX  is included in  X .",
            "title": "get_leftIdeals"
        },
        {
            "location": "/categoryaction/#get_rightideals",
            "text": "get_rightIdeals()  Returns all right ideals in this monoid as a list of lists, each list being a right ideal.\nA right ideal is a subset  X  of the monoid, such that for any operation  m  in the monoid,  Xm  is included in  X .",
            "title": "get_rightIdeals"
        },
        {
            "location": "/categoryaction/#is_leftideal",
            "text": "is_leftIdeal(S)  Returns  True  if the subset  S  is a left ideal in the monoid.",
            "title": "is_leftIdeal"
        },
        {
            "location": "/categoryaction/#is_rightideal",
            "text": "is_rightIdeal(S)  Returns  True  if the subset  S  is a right ideal in the monoid.",
            "title": "is_rightIdeal"
        },
        {
            "location": "/categoryaction/#categoryfunctor",
            "text": "opycleid.categoryaction.CategoryFunctor(cat_action_source,cat_action_target)  A  CategoryFunctor  instance represents a functor   N \\colon \\mathbf{C} \\to \\mathbf{C}'   between the categories   \\mathbf{C}   and   \\mathbf{C}'   corresponding to the category actions   S \\colon \\mathbf{C} \\to \\mathbf{Rel}   and   S' \\colon \\mathbf{C'} \\to \\mathbf{Rel}  .  It is instantiated by specifying two instances  cat_action_source  and  cat_action_target  of  opycleid.categoryaction.CategoryAction , i.e. the domain and codomain of the functor   N \\colon \\mathbf{C} \\to \\mathbf{C}'  .",
            "title": "CategoryFunctor"
        },
        {
            "location": "/categoryaction/#methods_4",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/categoryaction/#set_fullmapping",
            "text": "set_fullmapping(object_mapping,morphism_mapping)  Sets the mapping of morphisms and objects between the domain and codomain category actions. The method checks that the given mappings are\nvalid, i.e. that   for every morphism   f \\colon X \\to Y   of   \\mathbf{C}  , the image morphism by   N   is a morphism from   N(X)   to   N(Y)  .  for every morphisms   f,g   of   \\mathbf{C}  , we have   N(g \\circ f) = N(g) \\circ N(f)  .   The arguments of this method are as follows.   object_mapping  is a dictionary, the keys of which are object names in the source category action, the values of which are object names in the target category action.  morphism_mapping  is a dictionary, the keys of which are morphism names in the source category action, the values of which are morphism names in the target category action.   Returns  True  if the given mappings are valid,  False  otherwise.",
            "title": "set_fullmapping"
        },
        {
            "location": "/categoryaction/#set_fullmapping_1",
            "text": "set_from_generator_mapping(gen_mapping)  Sets the mapping of morphisms and objects between the domain and codomain category actions from a mapping of the generators of the source category action.\nThe argument  gen_mapping  is a dictionary, the keys of which are generator names in the source category action, the values of which are morphism names in the target category action. The full mapping of objects and morphisms is deduced from the generator mapping.\nThe method checks that the given generator mapping is valid, and returns  True  if this is case,  False  otherwise.",
            "title": "set_fullmapping"
        },
        {
            "location": "/categoryaction/#get_image_object",
            "text": "get_image_object(object_name)  Returns the image of an object of the source category action by the category functor. The argument  object_name  is a string representing the name of an object in the source category of this functor. A string representing the image of  object_name  in the target category action of this functor is returned.",
            "title": "get_image_object"
        },
        {
            "location": "/categoryaction/#get_image_morphism",
            "text": "get_image_morphism(morphism_name)  Returns the image of a morphism of the source category action by the category functor. The argument  morphism_name  is a string representing the name of a morphism in the source category of this functor. A string representing the image of  morphism_name  in the target category action of this functor is returned.",
            "title": "get_image_morphism"
        },
        {
            "location": "/categoryaction/#get_object_mapping",
            "text": "get_object_mapping()  Returns the full mapping of objects by the category functor as a dictionary.",
            "title": "get_object_mapping"
        },
        {
            "location": "/categoryaction/#get_morphism_mapping",
            "text": "get_morphism_mapping()  Returns the full mapping of morphisms by the category functor as a dictionary.  --",
            "title": "get_morphism_mapping"
        },
        {
            "location": "/categoryaction/#is_valid",
            "text": "is_valid()  Checks if the category functor is a valid one, returns  True  if this is case,  False  otherwise.  --",
            "title": "is_valid"
        },
        {
            "location": "/categoryaction/#is_automorphism",
            "text": "is_automorphism()  Checks if the category functor is an automorphism, i.e. the source and target categories are identical, and the mapping of objects and morphisms is bijective. Returns  True  if this is case,  False  otherwise.",
            "title": "is_automorphism"
        },
        {
            "location": "/categoryaction/#mul_1",
            "text": "Overloads the  *  operator in order to represent category functor composition.\nA typical use is  CategoryFunctor_2 * CategoryFunctor_1 .\nIf the target category of  CategoryFunctor_1  is identical to the source category of  CategoryFunctor_2 , this returns the corresponding composite functor.\nOtherwise, the two functors are not composable and an exception will be raised.",
            "title": "mul"
        },
        {
            "location": "/categoryaction/#eq_1",
            "text": "Overloads the  ==  operator in order to represent category functor equality.\nA typical use is  CategoryFunctor_2 == CategoryFunctor_1 .\nReturns  True  if this the mapping of objects and morphisms are identical,  False  otherwise.",
            "title": "eq"
        },
        {
            "location": "/categoryaction/#categoryactionfunctor",
            "text": "opycleid.categoryaction.CategoryActionFunctor(cat_action_source,cat_action_target,cat_functor,nat_transform)  A  CategoryActionFunctor  instance represents a morphism between two category actions   F \\colon \\mathbf{C} \\to \\mathbf{Rel}   and   F' \\colon \\mathbf{C'} \\to \\mathbf{Rel}  . Such a morphism is the data of a pair   (N,\\nu)   where     N   is a functor from   \\mathbf{C}   to   \\mathbf{C'}  , and    \\nu   is a lax natural transformation from   S   to   S'N  .   It is instantiated by specifying   two instances  cat_action_source  and  cat_action_target  of  opycleid.categoryaction.CategoryAction , i.e. the domain and codomain of the functor   N \\colon \\mathbf{C} \\to \\mathbf{C}'  ,  an instance  cat_functor  of  opycleid.categoryaction.CategoryFunctor  representing the functor   N \\colon \\mathbf{C} \\to \\mathbf{C}'  , and  a dictionary  nat_transform  representing the natural transformation   \\nu \\colon S \\to S'N  . The keys of this dictionary are object names in the source category action   S \\colon \\mathbf{C} \\to \\mathbf{Rel}  , the values are instances of  opycleid.categoryactionCatMorphism  from the object to their images.",
            "title": "CategoryActionFunctor"
        },
        {
            "location": "/categoryaction/#methods_5",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/categoryaction/#is_valid_1",
            "text": "is_valid()  Checks if the category action functor is a valid one, i.e. that   the functor   N \\mathbf{C} \\to \\mathbf{C'}   is a valid one, and  the lax natural transformation   \\nu   is valid, i.e. that for any morphism   f \\colon X \\to Y   in the source category action, the relation   \\nu_Y \\circ S(f)   is included in the relation   S'N(f) \\circ \\nu_X  .   Returns  True  if the category action functor is a valid one,  False  otherwise.",
            "title": "is_valid"
        },
        {
            "location": "/categoryaction/#mul_2",
            "text": "Overloads the  *  operator in order to represent category action functor composition.\nA typical use is  CategoryActionFunctor_2 * CategoryActionFunctor_1 .\nIf the target category action of  CategoryActionFunctor_1  is identical to the source category action of  CategoryActionFunctor_2 , this returns the corresponding composite category action functor, corresponding to the data of   (N_2 \\circ N_1,N_1\\nu_2 \\circ \\nu_1)  \nOtherwise, the two category action functors are not composable and an exception will be raised.",
            "title": "mul"
        },
        {
            "location": "/categoryaction/#eq_2",
            "text": "Overloads the  ==  operator in order to represent category action functor equality.\nA typical use is  CategoryActionFunctor_2 == CategoryActionFunctor_1 .\nReturns  True  if this both the category functor and the natural transformation are equal,  False  otherwise.",
            "title": "eq"
        },
        {
            "location": "/musicmonoids/",
            "text": "opycleid.musicmonoids\n\n\nThis module includes musical monoids and groups commonly encountered in TMT.\n\n\nNoll_Monoid\n\n\nopycleid.musicmonoids.Noll_Monoid()\n\n\n\n\nThis monoid of 8 elements acts on the set of the twelve pitch classes \n \\{C,C\\sharp,D,E\\flat,E,F,F\\sharp,G,G\\sharp,A,B\\flat,B\\} \n encoded with the usual semi-tone encoding, i.e. the set \n \\mathbb{Z}_{12} \n with \n C=0, C\\sharp=1, \\text{etc.} \n.\n\n\nIt is defined by Thomas Noll as the monoid generated by the two transformations \n f \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12} \n and\n\n g \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12} \n such that\n\n f(x)= 3x+7,\n\nand\n\n g(x)= 8x+4.\n\n\n\n\nReferences\n\n\nThomas Noll: The topos of triads, In: Colloquium on Mathematical Music Theory, Volume 347 of Grazer Math. Ber. Karl-Franzens-Univ. Graz, pp. 103\u2013135, (2005).\n\n\n\n\nTI_Group_PC\n\n\nopycleid.musicmonoids.TI_Group_PC()\n\n\n\n\nThis group is the commonly named \n T\\text{/}I \n group which acts on the set of the twelve pitch classes \n \\{C,C\\sharp,D,E\\flat,E,F,F\\sharp,G,G\\sharp,A,B\\flat,B\\} \n encoded with the usual semi-tone encoding.\n\n\nIt is isomorphic to the dihedral group \n D_{24} \n of order 24, and is generated by the following two transformations.\n\n\n\n\nThe transformation \n T_1 \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12} \n is called the \ntransposition operation\n, and is such that \nT_1(x)=x+1\n\n\n\n\nThe transformation \n I_0 \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12} \n is called the \ninversion operation\n, and is such that \nI_0(x)=-x\n\n\n\n\n\n\nExample\n\n\nfrom opycleid.musicmonoids import TI_Group_PC\n\nmy_group = TI_Group_PC()\nprint(my_group.get_operation(\nD\n,\nA\n)) ## ['T7', 'I11']\nprint(my_group.apply_operation(\nI11\n,\nB\n)) ## ['C']\nprint(my_group.mult(\nI11\n,\nT3\n)) ## \nI8\n\n\n\n\n\nReferences\n\n\nAlissa S. Crans, Thomas M. Fiore \n Ramon Satyendra: Musical Actions of Dihedral Groups, The American Mathematical Monthly, 116:6, pp. 479-495, (2018).\n\n\n\n\nTI_Group_Triads\n\n\nopycleid.musicmonoids.TI_Group_Triads()\n\n\n\n\nThis group is the commonly named \n T\\text{/}I \n group which acts simply transitively on the set \n \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\}\n of the 24 major and minor triads, where \nn_M\n (resp. \nn_m\n) represents a major (resp. minor) triad with root \nn\n in the usual semi-tone encoding of pitch classes.\n\n\nIt is isomorphic to the dihedral group \n D_{24} \n of order 24, and is generated by the following two transformations.\n\n\n\n\nThe transformation \n T_1 \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12} \n is called the \ntransposition operation\n, and is such that \n T_1(n_M)=(n+1)_M, T_1(n_m)=(n+1)_m \n\n\n\n\nThe transformation \n I_0 \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12} \n is called the \ninversion operation\n, and is such that \n I_0(n_M)=(5-n)_m \n\n\n\n\n\n\nIn effect, the \n T_1\n and \n I_0\n operations act element-wise on the pitch classes constituting the chords.\n\n\nExample\n\n\nfrom opycleid.musicmonoids import TI_Group_Triads\n\nmy_group = TI_Group_Triads()\nprint(my_group.get_operation(\nE_M\n,\nGs_m\n)) ## ['I7']\nprint(my_group.apply_operation(\nI7\n,\nB_M\n)) ## ['Cs_m']\nprint(my_group.mult(\nI7\n,\nT4\n)) ## \nI3\n\n\n\n\n\nReferences\n\n\nAlissa S. Crans, Thomas M. Fiore \n Ramon Satyendra: Musical Actions of Dihedral Groups, The American Mathematical Monthly, 116:6, pp. 479-495, (2018).\n\n\n\n\nPRL_Group\n\n\nopycleid.musicmonoids.PRL_Group()\n\n\n\n\nThis group is the \n \\text{PRL} \n group commonly used in neo-Riemannian theory, which acts simply transitively on the set \n \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\}\n of the 24 major and minor triads, where \nn_M\n (resp. \nn_m\n) represents a major (resp. minor) triad with root \nn\n in the usual semi-tone encoding of pitch classes.\n\n\nIt is isomorphic to the dihedral group \n D_{24} \n of order 24, and is generated by the following two transformations.\n\n\n\n\nThe transformation \n L \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12} \n is called the \nleading-tone operation\n, and is such that \n L(n_M)=(n+4)_m\n\n\n\n\nThe transformation \n R \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12} \n is called the \nrelative operation\n, and is such that \n R(n_M)=(n+9)_m \n\n\n\n\n\n\nThough not a generator, the operation \n P = (RL)^3R \n, called the \nparallel operation\n, is often considered, and is such that \n P(n_M)=n_m \n.\n\n\nExample\n\n\nfrom opycleid.musicmonoids import PRL_Group\n\nmy_group = PRL_Group()\nprint(my_group.get_operation(\nE_M\n,\nGs_m\n)) ## ['L']\nprint(my_group.apply_operation(\nLPR\n,\nB_M\n)) ## ['C_m']\nprint(my_group.mult(\nR\n,\nLPR\n)) ## \nPL\n\n\n\n\n\nReferences\n\n\n\n\nAlissa S. Crans, Thomas M. Fiore \n Ramon Satyendra (2018): Musical Actions of Dihedral Groups, The American Mathematical Monthly, 116:6, 479-495.\n\n\nNeo-Riemannian theory\n.\n\n\n\n\n\n\nUTT_Group\n\n\nopycleid.musicmonoids.UTT_Group()\n\n\n\n\nThis group is called the group of \nUniform Triadic Transformations (UTT)\n and was introduced by Julian Hook in his Ph.D. dissertation. It acts on the set \n \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\}\n of the 24 major and minor triads, where \nn_M\n (resp. \nn_m\n) represents a major (resp. minor) triad with root \nn\n in the usual semi-tone encoding of pitch classes.\n\n\nThe UTT group is isomorphic to the wreath product \n \\mathbb{Z}_{12} \\wr \\mathbb{Z}_2 \n of order 288 and its elements are usually notated as \n (p,q,\\sigma) \n, with \np=0\\ldots11\n, \nq=0\\ldots11\n, and \n \\sigma \\in \\{+,-\\} \n. Their action is as follows.\n\n\n\n\nThe UTT \n (p,q,+) \n sends the major triad \n n_M \n to \n (n+p)_M \n, and the minor triad \n n_m \n to \n (n+q)_m \n.\n\n\nThe UTT \n (p,q,-) \n sends the major triad \n n_M \n to \n (n+p)_m \n, and the minor triad \n n_m \n to \n (n+q)_M \n.\n\n\n\n\nExample\n\n\nfrom opycleid.musicmonoids import UTT_Group\n\nmy_group = UTT_Group()\nprint(my_group.get_operation(\nE_M\n,\nGs_m\n))\n## Returns\n## ['\n4,1,-\n', '\n4,3,-\n', '\n4,9,-\n', '\n4,7,-\n', '\n4,2,-\n',\n##  '\n4,11,-\n', '\n4,6,-\n', '\n4,10,-\n', '\n4,4,-\n', '\n4,0,-\n',\n##  '\n4,5,-\n', '\n4,8,-\n']\nprint(my_group.apply_operation(\n7,6,-\n,\nA_M\n)) ## ['E_m']\nprint(my_group.mult(\n3,5,-\n,\n2,9,-\n)) ## \n7,0,+\n\n\n\n\n\nReferences\n\n\nJulian Hook: Uniform triadic transformations, Journal of Music Theory, 46(1/2), pp. 57\u2013126, (2002).\n\n\n\n\nLeft_Z3Q8_Group\n\n\nopycleid.musicmonoids.Left_Z3Q8_Group()\n\n\n\n\nLike the \n T\\text{/}I \n group and the \n \\text{PRL} \n group, this group is an extension of \n \\mathbb{Z}_{12} \n by \n \\mathbb{Z}_2 \n which acts simply transitively on the set \n \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\}\n of the 24 major and minor triads as defined above.\n\n\nIt is generated by the following two transformations.\n\n\n\n\nThe transformation \n T_1 \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12} \n such that \n T_1(n_M)=(n+1)_M, T_1(n_m)=(n+1)_m.\n\n\n\n\nThe transformation \n J_0 \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12} \n such that \n J_0(n_M)=(-n)_m, J_0(n_m)=(-n+6)_M.\n\n\n\n\n\n\nExample\n\n\nfrom opycleid.musicmonoids import Left_Z3Q8_Group\n\nmy_group = Left_Z3Q8_Group()\nprint(my_group.get_operation(\nE_M\n,\nGs_m\n)) ## ['J0']\nprint(my_group.apply_operation(\nJ0\n,\nGs_m\n)) ## ['Bb_M']\nprint(my_group.mult(\nJ3\n,\nT2\n)) ## \nJ1\n\n\n\n\n\nReferences\n\n\nAlexandre Popoff: Building Generalized Neo-Riemannian Groups of Musical Transformations as Extensions, Journal of Mathematics and Music, 7(1), pp. 55\u201372, (2013).\n\n\n\n\nRight_Z3Q8_Group\n\n\nopycleid.musicmonoids.Right_Z3Q8_Group()\n\n\n\n\nThis group is the right version of the 'Left_Z3Q8_Group' above. It also acts simply transitively on the set of major and minor triads, and is generated by the following two transformations.\n\n\n\n\nThe transformation \n T_1 \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12} \n such that \n T_1(n_M)=(n+1)_M, T_1(n_m)=(n-1)_m.\n\n\n\n\nThe transformation \n J_0 \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12} \n such that \n J_0(n_M)=n_m, J_0(n_m)=(n+6)_M.\n\n\n\n\n\n\nExample\n\n\nfrom opycleid.musicmonoids import Right_Z3Q8_Group\n\nmy_group = Right_Z3Q8_Group()\nprint(my_group.get_operation(\nE_M\n,\nGs_m\n)) ## ['J8']\nprint(my_group.apply_operation(\nJ0\n,\nGs_m\n)) ## ['D_M']\nprint(my_group.mult(\nJ3\n,\nT2\n)) ## \nJ1\n\n\n\n\n\nReferences\n\n\nAlexandre Popoff: Building Generalized Neo-Riemannian Groups of Musical Transformations as Extensions, Journal of Mathematics and Music, 7(1), pp. 55\u201372, (2013).\n\n\n\n\nUPL_Monoid\n\n\nopycleid.musicmonoids.UPL_Monoid()\n\n\n\n\nA monoid which acts on the set \n \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\} \\cup \\{n_{\\text{aug}}, n=0\\ldots3\\}\n of the 28 major, minor, and augmented triads, where \nn_M\n (resp. \nn_m\n, \nn_{\\text{aug}}\n) represents a major (resp. minor, augmented) triad with root \nn\n in the usual semi-tone encoding of pitch classes.\n\n\nIt is generated by the following three relations.\n\n\n\n\n\n\nThe relation \n \\mathcal{P} \n is the symmetric relation such that we have \n n_M \\mathcal{P} n_m\n for \n 0 \\leq n \\leq 11\n, and \nn_\\text{aug} \\mathcal{P} n_\\text{aug}\n for \n0 \\leq n \\leq 3\n. This is the relational analogue of the neo-Riemannian \nP\n operation.\n\n\n\n\n\n\nThe relation \n\\mathcal{L}\n is the symmetric relation such that we have \nn_M \\mathcal{L} (n+4)_m\n for \n0 \\leq n \\leq 11\n, and \nn_\\text{aug} \\mathcal{L} n_\\text{aug}\n for \n0 \\leq n \\leq 3\n. This is the relational analogue of the neo-Riemannian \nL\n operation.\n\n\n\n\n\n\nThe relation \n\\mathcal{U}\n is the symmetric relation such that we have \nn_M \\mathcal{U} (n \\pmod 4)_\\text{aug}\n for \n0 \\leq n \\leq 11\n, and \nn_m \\mathcal{U} ((n+3) \\pmod 4)_\\text{aug}\n for \n0 \\leq n \\leq 11\n. It relates major and minor triads to augmented triads.\n\n\n\n\n\n\nNote that for any of these generators, two triads are related if they differ by a single semi-tone move.\n\n\nExample\n\n\nfrom opycleid.musicmonoids import UPL_Monoid\n\nmy_group = UPL_Monoid()\nprint(my_group.get_operation(\nE_M\n,\nF_aug\n))\n## Returns ['PUPUU', 'UPUU', 'UPUPU', 'PUPUPU']\nprint(my_group.apply_operation(\nU\n,\nF_aug\n))\n## Returns ['Cs_M', 'F_M', 'A_M', 'D_m', 'Fs_m', 'Bb_m']\nprint(my_group.mult(\nU\n,\nUUPUU\n)) ## \nUPUU\n\n\n\n\n\nReferences\n\n\nAlexandre Popoff, Moreno Andreatta, Andr\u00e9e Ehresmann: Relational PK-Nets for Transformational Music Analysis, \narXiv:1611.02249\n.\n\n\n\n\nS_Monoid\n\n\nopycleid.musicmonoids.S_Monoid()\n\n\n\n\nA monoid which acts on the set \n \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\} \\cup \\{n_{\\text{aug}}, n=0\\ldots3\\}\n of the 28 major, minor, and augmented triads, where \nn_M\n (resp. \nn_m\n, \nn_{\\text{aug}}\n) represents a major (resp. minor, augmented) triad with root \nn\n in the usual semi-tone encoding of pitch classes.\n\n\nIt is generated by the \n\\mathcal{S}\n relation defined as the symmetric relation such that we have \n n_M \\mathcal{S} n_m \n, \n n_M \\mathcal{S} (n+4)_m\n, \nn_M \\mathcal{S} (n \\pmod{4})_\\text{aug}\n, and \nn_m \\mathcal{S} ((n+3) \\pmod{4})_\\text{aug}\n for \n0 \\leq n \\leq 11\n. This relations is the same as the \n\\mathcal{P}_{1,0}\n relation introduced by Douthett in his work on parsimonious graphs. Two triads are related by \n\\mathcal{S}\n if they differ by a single semi-tone move.\n\n\nExample\n\n\nfrom opycleid.musicmonoids import S_Monoid\n\nmy_group = S_Monoid()\nprint(my_group.get_operation(\nE_M\n,\nF_aug\n))\n## Returns ['SSSS', 'SSSSSS']\nprint(my_group.apply_operation(\nS\n,\nE_M\n))\n## Returns ['E_m', 'Gs_m', 'C_aug']\n\n\n\n\nReferences\n\n\nDouthett, J., Steinbach, P.: Parsimonious Graphs: A Study in Parsimony, Contextual Transformations, and Modes of Limited Transposition, Journal of Music Theory, 42(2), pp. 241-263, (1998).\n\n\n\n\nT_Monoid\n\n\nopycleid.musicmonoids.T_Monoid()\n\n\n\n\nA monoid which acts on the set \n \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\} \\cup \\{n_{\\text{aug}}, n=0\\ldots3\\}\n of the 28 major, minor, and augmented triads, where \nn_M\n (resp. \nn_m\n, \nn_{\\text{aug}}\n) represents a major (resp. minor, augmented) triad with root \nn\n in the usual semi-tone encoding of pitch classes.\n\n\nIt is generated by the \n\\mathcal{T}\n relation defined as the symmetric relation such that we have, for \n0 \\leq n \\leq 11 \n,\n\n\n\n\n\n\nn_M \\mathcal{T} (n+4)_M,\n\n\n\n\n\n\nn_M \\mathcal{T} (n+8)_M,\n\n\n\n\n\n\nn_m \\mathcal{T} (n+4)_m,\n\n\n\n\n\n\nn_m \\mathcal{T} (n+8)_m,\n\n\n\n\n\n\nn_M \\mathcal{T} (n+1)_m,\n\n\n\n\n\n\nn_M \\mathcal{T} (n+5)_m,\n\n\n\n\n\n\nn_M \\mathcal{T} ((n+3) \\pmod{4})_\\text{aug},\n and\n\n\n\n\nn_m \\mathcal{T} (n \\pmod{4})_\\text{aug}.\n\n\n\n\n\n\nThis relation is the same as the \n\\mathcal{P}_{2,0}\n relation introduced by Douthett in his work on parsimonious graphs. Two triads are related by \n\\mathcal{T}\n if they differ by two semi-tone moves.\n\n\nExample\n\n\nfrom opycleid.musicmonoids import T_Monoid\n\nmy_group = T_Monoid()\nprint(my_group.get_operation(\nE_M\n,\nF_aug\n))\n## Returns ['TT', 'TTT']\nprint(my_group.apply_operation(\nT\n,\nE_M\n))\n## Returns ['C_M', 'Gs_M', 'F_m', 'A_m', 'G_aug']\n\n\n\n\nReferences\n\n\nDouthett, J., Steinbach, P.: Parsimonious Graphs: A Study in Parsimony, Contextual Transformations, and Modes of Limited Transposition, Journal of Music Theory, 42(2), pp. 241-263, (1998).\n\n\n\n\nK_Monoid\n\n\nopycleid.musicmonoids.K_Monoid()\n\n\n\n\nA monoid which acts on the set \n \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\} \\cup \\{n_{\\text{aug}}, n=0\\ldots3\\}\n of the 28 major, minor, and augmented triads, where \nn_M\n (resp. \nn_m\n, \nn_{\\text{aug}}\n) represents a major (resp. minor, augmented) triad with root \nn\n in the usual semi-tone encoding of pitch classes.\n\n\nIt is generated by the \n\\mathcal{K}\n relation. This is the same as the \n\\mathcal{P}_{2,1}\n relation introduced by Douthett in his work on parsimonious graphs. Two triads are related by \n\\mathcal{K}\n if they differ by the movement of two notes by a semitone each, and the remaining note by a tone.\n\n\nReferences\n\n\nDouthett, J., Steinbach, P.: Parsimonious Graphs: A Study in Parsimony, Contextual Transformations, and Modes of Limited Transposition, Journal of Music Theory, 42(2), pp. 241-263, (1998).\n\n\n\n\nW_Monoid\n\n\nopycleid.musicmonoids.W_Monoid()\n\n\n\n\nA monoid which acts on the set \n \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\} \\cup \\{n_{\\text{aug}}, n=0\\ldots3\\}\n of the 28 major, minor, and augmented triads, where \nn_M\n (resp. \nn_m\n, \nn_{\\text{aug}}\n) represents a major (resp. minor, augmented) triad with root \nn\n in the usual semi-tone encoding of pitch classes.\n\n\nIt is generated by the \n\\mathcal{K}\n relation. This is the same as the \n\\mathcal{P}_{1,2}\n relation introduced by Douthett in his work on parsimonious graphs. Two triads are related by \n\\mathcal{K}\n if they differ by the movement of a single note by a semitone, and the remaining notes by a tone each.\n\n\nReferences\n\n\nDouthett, J., Steinbach, P.: Parsimonious Graphs: A Study in Parsimony, Contextual Transformations, and Modes of Limited Transposition, Journal of Music Theory, 42(2), pp. 241-263, (1998).\n\n\n\n\nST_Monoid\n\n\nopycleid.musicmonoids.ST_Monoid()\n\n\n\n\nA monoid which acts on the set \n \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\} \\cup \\{n_{\\text{aug}}, n=0\\ldots3\\}\n of the 28 major, minor, and augmented triads, where \nn_M\n (resp. \nn_m\n, \nn_{\\text{aug}}\n) represents a major (resp. minor, augmented) triad with root \nn\n in the usual semi-tone encoding of pitch classes.\n\n\nIt is generated by the two relations \n\\mathcal{S}\n and \n\\mathcal{T}\n described above.",
            "title": "opycleid.musicmonoids"
        },
        {
            "location": "/musicmonoids/#opycleidmusicmonoids",
            "text": "This module includes musical monoids and groups commonly encountered in TMT.",
            "title": "opycleid.musicmonoids"
        },
        {
            "location": "/musicmonoids/#noll_monoid",
            "text": "opycleid.musicmonoids.Noll_Monoid()  This monoid of 8 elements acts on the set of the twelve pitch classes   \\{C,C\\sharp,D,E\\flat,E,F,F\\sharp,G,G\\sharp,A,B\\flat,B\\}   encoded with the usual semi-tone encoding, i.e. the set   \\mathbb{Z}_{12}   with   C=0, C\\sharp=1, \\text{etc.}  .  It is defined by Thomas Noll as the monoid generated by the two transformations   f \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12}   and  g \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12}   such that  f(x)= 3x+7, \nand  g(x)= 8x+4.",
            "title": "Noll_Monoid"
        },
        {
            "location": "/musicmonoids/#references",
            "text": "Thomas Noll: The topos of triads, In: Colloquium on Mathematical Music Theory, Volume 347 of Grazer Math. Ber. Karl-Franzens-Univ. Graz, pp. 103\u2013135, (2005).",
            "title": "References"
        },
        {
            "location": "/musicmonoids/#ti_group_pc",
            "text": "opycleid.musicmonoids.TI_Group_PC()  This group is the commonly named   T\\text{/}I   group which acts on the set of the twelve pitch classes   \\{C,C\\sharp,D,E\\flat,E,F,F\\sharp,G,G\\sharp,A,B\\flat,B\\}   encoded with the usual semi-tone encoding.  It is isomorphic to the dihedral group   D_{24}   of order 24, and is generated by the following two transformations.   The transformation   T_1 \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12}   is called the  transposition operation , and is such that  T_1(x)=x+1   The transformation   I_0 \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12}   is called the  inversion operation , and is such that  I_0(x)=-x",
            "title": "TI_Group_PC"
        },
        {
            "location": "/musicmonoids/#example",
            "text": "from opycleid.musicmonoids import TI_Group_PC\n\nmy_group = TI_Group_PC()\nprint(my_group.get_operation( D , A )) ## ['T7', 'I11']\nprint(my_group.apply_operation( I11 , B )) ## ['C']\nprint(my_group.mult( I11 , T3 )) ##  I8",
            "title": "Example"
        },
        {
            "location": "/musicmonoids/#references_1",
            "text": "Alissa S. Crans, Thomas M. Fiore   Ramon Satyendra: Musical Actions of Dihedral Groups, The American Mathematical Monthly, 116:6, pp. 479-495, (2018).",
            "title": "References"
        },
        {
            "location": "/musicmonoids/#ti_group_triads",
            "text": "opycleid.musicmonoids.TI_Group_Triads()  This group is the commonly named   T\\text{/}I   group which acts simply transitively on the set   \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\}  of the 24 major and minor triads, where  n_M  (resp.  n_m ) represents a major (resp. minor) triad with root  n  in the usual semi-tone encoding of pitch classes.  It is isomorphic to the dihedral group   D_{24}   of order 24, and is generated by the following two transformations.   The transformation   T_1 \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12}   is called the  transposition operation , and is such that   T_1(n_M)=(n+1)_M, T_1(n_m)=(n+1)_m    The transformation   I_0 \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12}   is called the  inversion operation , and is such that   I_0(n_M)=(5-n)_m     In effect, the   T_1  and   I_0  operations act element-wise on the pitch classes constituting the chords.",
            "title": "TI_Group_Triads"
        },
        {
            "location": "/musicmonoids/#example_1",
            "text": "from opycleid.musicmonoids import TI_Group_Triads\n\nmy_group = TI_Group_Triads()\nprint(my_group.get_operation( E_M , Gs_m )) ## ['I7']\nprint(my_group.apply_operation( I7 , B_M )) ## ['Cs_m']\nprint(my_group.mult( I7 , T4 )) ##  I3",
            "title": "Example"
        },
        {
            "location": "/musicmonoids/#references_2",
            "text": "Alissa S. Crans, Thomas M. Fiore   Ramon Satyendra: Musical Actions of Dihedral Groups, The American Mathematical Monthly, 116:6, pp. 479-495, (2018).",
            "title": "References"
        },
        {
            "location": "/musicmonoids/#prl_group",
            "text": "opycleid.musicmonoids.PRL_Group()  This group is the   \\text{PRL}   group commonly used in neo-Riemannian theory, which acts simply transitively on the set   \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\}  of the 24 major and minor triads, where  n_M  (resp.  n_m ) represents a major (resp. minor) triad with root  n  in the usual semi-tone encoding of pitch classes.  It is isomorphic to the dihedral group   D_{24}   of order 24, and is generated by the following two transformations.   The transformation   L \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12}   is called the  leading-tone operation , and is such that   L(n_M)=(n+4)_m   The transformation   R \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12}   is called the  relative operation , and is such that   R(n_M)=(n+9)_m     Though not a generator, the operation   P = (RL)^3R  , called the  parallel operation , is often considered, and is such that   P(n_M)=n_m  .",
            "title": "PRL_Group"
        },
        {
            "location": "/musicmonoids/#example_2",
            "text": "from opycleid.musicmonoids import PRL_Group\n\nmy_group = PRL_Group()\nprint(my_group.get_operation( E_M , Gs_m )) ## ['L']\nprint(my_group.apply_operation( LPR , B_M )) ## ['C_m']\nprint(my_group.mult( R , LPR )) ##  PL",
            "title": "Example"
        },
        {
            "location": "/musicmonoids/#references_3",
            "text": "Alissa S. Crans, Thomas M. Fiore   Ramon Satyendra (2018): Musical Actions of Dihedral Groups, The American Mathematical Monthly, 116:6, 479-495.  Neo-Riemannian theory .",
            "title": "References"
        },
        {
            "location": "/musicmonoids/#utt_group",
            "text": "opycleid.musicmonoids.UTT_Group()  This group is called the group of  Uniform Triadic Transformations (UTT)  and was introduced by Julian Hook in his Ph.D. dissertation. It acts on the set   \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\}  of the 24 major and minor triads, where  n_M  (resp.  n_m ) represents a major (resp. minor) triad with root  n  in the usual semi-tone encoding of pitch classes.  The UTT group is isomorphic to the wreath product   \\mathbb{Z}_{12} \\wr \\mathbb{Z}_2   of order 288 and its elements are usually notated as   (p,q,\\sigma)  , with  p=0\\ldots11 ,  q=0\\ldots11 , and   \\sigma \\in \\{+,-\\}  . Their action is as follows.   The UTT   (p,q,+)   sends the major triad   n_M   to   (n+p)_M  , and the minor triad   n_m   to   (n+q)_m  .  The UTT   (p,q,-)   sends the major triad   n_M   to   (n+p)_m  , and the minor triad   n_m   to   (n+q)_M  .",
            "title": "UTT_Group"
        },
        {
            "location": "/musicmonoids/#example_3",
            "text": "from opycleid.musicmonoids import UTT_Group\n\nmy_group = UTT_Group()\nprint(my_group.get_operation( E_M , Gs_m ))\n## Returns\n## [' 4,1,- ', ' 4,3,- ', ' 4,9,- ', ' 4,7,- ', ' 4,2,- ',\n##  ' 4,11,- ', ' 4,6,- ', ' 4,10,- ', ' 4,4,- ', ' 4,0,- ',\n##  ' 4,5,- ', ' 4,8,- ']\nprint(my_group.apply_operation( 7,6,- , A_M )) ## ['E_m']\nprint(my_group.mult( 3,5,- , 2,9,- )) ##  7,0,+",
            "title": "Example"
        },
        {
            "location": "/musicmonoids/#references_4",
            "text": "Julian Hook: Uniform triadic transformations, Journal of Music Theory, 46(1/2), pp. 57\u2013126, (2002).",
            "title": "References"
        },
        {
            "location": "/musicmonoids/#left_z3q8_group",
            "text": "opycleid.musicmonoids.Left_Z3Q8_Group()  Like the   T\\text{/}I   group and the   \\text{PRL}   group, this group is an extension of   \\mathbb{Z}_{12}   by   \\mathbb{Z}_2   which acts simply transitively on the set   \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\}  of the 24 major and minor triads as defined above.  It is generated by the following two transformations.   The transformation   T_1 \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12}   such that   T_1(n_M)=(n+1)_M, T_1(n_m)=(n+1)_m.   The transformation   J_0 \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12}   such that   J_0(n_M)=(-n)_m, J_0(n_m)=(-n+6)_M.",
            "title": "Left_Z3Q8_Group"
        },
        {
            "location": "/musicmonoids/#example_4",
            "text": "from opycleid.musicmonoids import Left_Z3Q8_Group\n\nmy_group = Left_Z3Q8_Group()\nprint(my_group.get_operation( E_M , Gs_m )) ## ['J0']\nprint(my_group.apply_operation( J0 , Gs_m )) ## ['Bb_M']\nprint(my_group.mult( J3 , T2 )) ##  J1",
            "title": "Example"
        },
        {
            "location": "/musicmonoids/#references_5",
            "text": "Alexandre Popoff: Building Generalized Neo-Riemannian Groups of Musical Transformations as Extensions, Journal of Mathematics and Music, 7(1), pp. 55\u201372, (2013).",
            "title": "References"
        },
        {
            "location": "/musicmonoids/#right_z3q8_group",
            "text": "opycleid.musicmonoids.Right_Z3Q8_Group()  This group is the right version of the 'Left_Z3Q8_Group' above. It also acts simply transitively on the set of major and minor triads, and is generated by the following two transformations.   The transformation   T_1 \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12}   such that   T_1(n_M)=(n+1)_M, T_1(n_m)=(n-1)_m.   The transformation   J_0 \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12}   such that   J_0(n_M)=n_m, J_0(n_m)=(n+6)_M.",
            "title": "Right_Z3Q8_Group"
        },
        {
            "location": "/musicmonoids/#example_5",
            "text": "from opycleid.musicmonoids import Right_Z3Q8_Group\n\nmy_group = Right_Z3Q8_Group()\nprint(my_group.get_operation( E_M , Gs_m )) ## ['J8']\nprint(my_group.apply_operation( J0 , Gs_m )) ## ['D_M']\nprint(my_group.mult( J3 , T2 )) ##  J1",
            "title": "Example"
        },
        {
            "location": "/musicmonoids/#references_6",
            "text": "Alexandre Popoff: Building Generalized Neo-Riemannian Groups of Musical Transformations as Extensions, Journal of Mathematics and Music, 7(1), pp. 55\u201372, (2013).",
            "title": "References"
        },
        {
            "location": "/musicmonoids/#upl_monoid",
            "text": "opycleid.musicmonoids.UPL_Monoid()  A monoid which acts on the set   \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\} \\cup \\{n_{\\text{aug}}, n=0\\ldots3\\}  of the 28 major, minor, and augmented triads, where  n_M  (resp.  n_m ,  n_{\\text{aug}} ) represents a major (resp. minor, augmented) triad with root  n  in the usual semi-tone encoding of pitch classes.  It is generated by the following three relations.    The relation   \\mathcal{P}   is the symmetric relation such that we have   n_M \\mathcal{P} n_m  for   0 \\leq n \\leq 11 , and  n_\\text{aug} \\mathcal{P} n_\\text{aug}  for  0 \\leq n \\leq 3 . This is the relational analogue of the neo-Riemannian  P  operation.    The relation  \\mathcal{L}  is the symmetric relation such that we have  n_M \\mathcal{L} (n+4)_m  for  0 \\leq n \\leq 11 , and  n_\\text{aug} \\mathcal{L} n_\\text{aug}  for  0 \\leq n \\leq 3 . This is the relational analogue of the neo-Riemannian  L  operation.    The relation  \\mathcal{U}  is the symmetric relation such that we have  n_M \\mathcal{U} (n \\pmod 4)_\\text{aug}  for  0 \\leq n \\leq 11 , and  n_m \\mathcal{U} ((n+3) \\pmod 4)_\\text{aug}  for  0 \\leq n \\leq 11 . It relates major and minor triads to augmented triads.    Note that for any of these generators, two triads are related if they differ by a single semi-tone move.",
            "title": "UPL_Monoid"
        },
        {
            "location": "/musicmonoids/#example_6",
            "text": "from opycleid.musicmonoids import UPL_Monoid\n\nmy_group = UPL_Monoid()\nprint(my_group.get_operation( E_M , F_aug ))\n## Returns ['PUPUU', 'UPUU', 'UPUPU', 'PUPUPU']\nprint(my_group.apply_operation( U , F_aug ))\n## Returns ['Cs_M', 'F_M', 'A_M', 'D_m', 'Fs_m', 'Bb_m']\nprint(my_group.mult( U , UUPUU )) ##  UPUU",
            "title": "Example"
        },
        {
            "location": "/musicmonoids/#references_7",
            "text": "Alexandre Popoff, Moreno Andreatta, Andr\u00e9e Ehresmann: Relational PK-Nets for Transformational Music Analysis,  arXiv:1611.02249 .",
            "title": "References"
        },
        {
            "location": "/musicmonoids/#s_monoid",
            "text": "opycleid.musicmonoids.S_Monoid()  A monoid which acts on the set   \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\} \\cup \\{n_{\\text{aug}}, n=0\\ldots3\\}  of the 28 major, minor, and augmented triads, where  n_M  (resp.  n_m ,  n_{\\text{aug}} ) represents a major (resp. minor, augmented) triad with root  n  in the usual semi-tone encoding of pitch classes.  It is generated by the  \\mathcal{S}  relation defined as the symmetric relation such that we have   n_M \\mathcal{S} n_m  ,   n_M \\mathcal{S} (n+4)_m ,  n_M \\mathcal{S} (n \\pmod{4})_\\text{aug} , and  n_m \\mathcal{S} ((n+3) \\pmod{4})_\\text{aug}  for  0 \\leq n \\leq 11 . This relations is the same as the  \\mathcal{P}_{1,0}  relation introduced by Douthett in his work on parsimonious graphs. Two triads are related by  \\mathcal{S}  if they differ by a single semi-tone move.",
            "title": "S_Monoid"
        },
        {
            "location": "/musicmonoids/#example_7",
            "text": "from opycleid.musicmonoids import S_Monoid\n\nmy_group = S_Monoid()\nprint(my_group.get_operation( E_M , F_aug ))\n## Returns ['SSSS', 'SSSSSS']\nprint(my_group.apply_operation( S , E_M ))\n## Returns ['E_m', 'Gs_m', 'C_aug']",
            "title": "Example"
        },
        {
            "location": "/musicmonoids/#references_8",
            "text": "Douthett, J., Steinbach, P.: Parsimonious Graphs: A Study in Parsimony, Contextual Transformations, and Modes of Limited Transposition, Journal of Music Theory, 42(2), pp. 241-263, (1998).",
            "title": "References"
        },
        {
            "location": "/musicmonoids/#t_monoid",
            "text": "opycleid.musicmonoids.T_Monoid()  A monoid which acts on the set   \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\} \\cup \\{n_{\\text{aug}}, n=0\\ldots3\\}  of the 28 major, minor, and augmented triads, where  n_M  (resp.  n_m ,  n_{\\text{aug}} ) represents a major (resp. minor, augmented) triad with root  n  in the usual semi-tone encoding of pitch classes.  It is generated by the  \\mathcal{T}  relation defined as the symmetric relation such that we have, for  0 \\leq n \\leq 11  ,    n_M \\mathcal{T} (n+4)_M,    n_M \\mathcal{T} (n+8)_M,    n_m \\mathcal{T} (n+4)_m,    n_m \\mathcal{T} (n+8)_m,    n_M \\mathcal{T} (n+1)_m,    n_M \\mathcal{T} (n+5)_m,    n_M \\mathcal{T} ((n+3) \\pmod{4})_\\text{aug},  and   n_m \\mathcal{T} (n \\pmod{4})_\\text{aug}.    This relation is the same as the  \\mathcal{P}_{2,0}  relation introduced by Douthett in his work on parsimonious graphs. Two triads are related by  \\mathcal{T}  if they differ by two semi-tone moves.",
            "title": "T_Monoid"
        },
        {
            "location": "/musicmonoids/#example_8",
            "text": "from opycleid.musicmonoids import T_Monoid\n\nmy_group = T_Monoid()\nprint(my_group.get_operation( E_M , F_aug ))\n## Returns ['TT', 'TTT']\nprint(my_group.apply_operation( T , E_M ))\n## Returns ['C_M', 'Gs_M', 'F_m', 'A_m', 'G_aug']",
            "title": "Example"
        },
        {
            "location": "/musicmonoids/#references_9",
            "text": "Douthett, J., Steinbach, P.: Parsimonious Graphs: A Study in Parsimony, Contextual Transformations, and Modes of Limited Transposition, Journal of Music Theory, 42(2), pp. 241-263, (1998).",
            "title": "References"
        },
        {
            "location": "/musicmonoids/#k_monoid",
            "text": "opycleid.musicmonoids.K_Monoid()  A monoid which acts on the set   \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\} \\cup \\{n_{\\text{aug}}, n=0\\ldots3\\}  of the 28 major, minor, and augmented triads, where  n_M  (resp.  n_m ,  n_{\\text{aug}} ) represents a major (resp. minor, augmented) triad with root  n  in the usual semi-tone encoding of pitch classes.  It is generated by the  \\mathcal{K}  relation. This is the same as the  \\mathcal{P}_{2,1}  relation introduced by Douthett in his work on parsimonious graphs. Two triads are related by  \\mathcal{K}  if they differ by the movement of two notes by a semitone each, and the remaining note by a tone.",
            "title": "K_Monoid"
        },
        {
            "location": "/musicmonoids/#references_10",
            "text": "Douthett, J., Steinbach, P.: Parsimonious Graphs: A Study in Parsimony, Contextual Transformations, and Modes of Limited Transposition, Journal of Music Theory, 42(2), pp. 241-263, (1998).",
            "title": "References"
        },
        {
            "location": "/musicmonoids/#w_monoid",
            "text": "opycleid.musicmonoids.W_Monoid()  A monoid which acts on the set   \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\} \\cup \\{n_{\\text{aug}}, n=0\\ldots3\\}  of the 28 major, minor, and augmented triads, where  n_M  (resp.  n_m ,  n_{\\text{aug}} ) represents a major (resp. minor, augmented) triad with root  n  in the usual semi-tone encoding of pitch classes.  It is generated by the  \\mathcal{K}  relation. This is the same as the  \\mathcal{P}_{1,2}  relation introduced by Douthett in his work on parsimonious graphs. Two triads are related by  \\mathcal{K}  if they differ by the movement of a single note by a semitone, and the remaining notes by a tone each.",
            "title": "W_Monoid"
        },
        {
            "location": "/musicmonoids/#references_11",
            "text": "Douthett, J., Steinbach, P.: Parsimonious Graphs: A Study in Parsimony, Contextual Transformations, and Modes of Limited Transposition, Journal of Music Theory, 42(2), pp. 241-263, (1998).",
            "title": "References"
        },
        {
            "location": "/musicmonoids/#st_monoid",
            "text": "opycleid.musicmonoids.ST_Monoid()  A monoid which acts on the set   \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\} \\cup \\{n_{\\text{aug}}, n=0\\ldots3\\}  of the 28 major, minor, and augmented triads, where  n_M  (resp.  n_m ,  n_{\\text{aug}} ) represents a major (resp. minor, augmented) triad with root  n  in the usual semi-tone encoding of pitch classes.  It is generated by the two relations  \\mathcal{S}  and  \\mathcal{T}  described above.",
            "title": "ST_Monoid"
        },
        {
            "location": "/knetanalysis/",
            "text": "opycleid.knetanalysis\n\n\nOverview\n\n\nThis module defines a class for performing Klumpenhouwer network (K-Net) and poly-Klumpenhouwer network (PK-Net) analysis.\n\n\nInformally, a K-Net is a directed graph, the vertices of which are labelled with musical objects,\nand the arrows of which are labelled with transformations between them. Arrows are understood to be composable: the label\nof a resulting composite arrow should be equal to the label of the composition of the two original arrows.\n\n\nA K-Net allows one to study the interconnections between different musical elements, for example in the study of the different intervals in the constitutive elements of chords in post-tonal music.\n\n\nRecent research (see below) has proposed new categorical formalizations of the K-Net notion, in which a K-Net can be conceived as the data \n (R,S,F,\\phi) \n of\n\n\n\n\na lax functor \n R \\colon \\Delta \\to \\mathbf{Rel} \n, called the \ndiagram action\n,\n\n\na functor \n S \\colon \\mathbf{C} \\to \\mathbf{Rel} \n where \n \\mathbf{C} \n is a finite category called the \ncontext action\n, and\n\n\na category action morphism \n (F, \\phi) \n between them, i.e. a functor \n F \\colon \\Delta \\to \\mathbf{C} \n, and a lax natural transformation \n \\phi \\colon R \\to SF \n (left-total on all components).\n\n\n\n\nComplete\n and \nlocal\n homographies allow to transform PK-Nets into one another. More precisely,\n\n\n\n\nComplete homographies correspond to category action morphisms \n (N, \\nu) \n between functors \n S \\colon \\mathbf{C} \\to \\mathbf{Rel} \n and \n S' \\colon \\mathbf{C'} \\to \\mathbf{Rel} \n and yield the new PK-Net \n (R,S',F'=NF,\\phi'=\\nu \\circ \\phi) \n.\n\n\nLocal homographies correspond to the data \n N, \\tilde{\\nu} \n of a functor \n N \\colon \\mathbf{C} \\to \\mathbf{C'} \n and a natural transformations \n \\tilde{\\nu} \n between functors \n F \\colon \\Delta \\to \\mathbf{C} \n and \n NF \\colon \\Delta \\to \\mathbf{C'} \n, which yields the new PK-Net \n (R,S',F'=NF,\\phi'=S\\tilde{\\nu} \\circ \\phi) \n.\n\n\n\n\nReferences\n\n\nReference literature on Klumpenhouwer networks:\n\n\n\n\nDavid Lewin: Klumpenhouwer Networks and Some Isographies That Involve Them, Music Theory Spectrum, Vol. 12, pp. 83\u2013120, (1990).\n\n\nDavid Lewin: A Tutorial on Klumpenhouwer Networks, Using the Chorale in Schoenberg\u2019s Opus 11, No. 2, Journal of Music Theory, Vol. 38, pp. 79\u2013101, (1994).\n\n\nHenri Klumpenhouwer: The Inner and Outer Automorphisms of Pitch-Class Inversion and Transposition: Some Implications for Analysis with Klumpenhouwer Networks, Int\u00e9gral, Vol. 12, pp. 81\u201393, (1998).\n\n\n\n\nCategorical approaches to Klumpenhouwer networks:\n\n\n\n\nGuerino Mazzola, Moreno Andreatta: From a Categorical Point of View: K-Nets as Limit Denotators, Perspectives of New Music, 44(2), pp. 88\u2013113, (2006).\n\n\nAlexandre Popoff, Moreno Andreatta, Andr\u00e9e Ehresmann: A Categorical Generalization of Klumpenhouwer Networks, Proceedings of MCM 2015, Vol. 9110 of Lecture Notes in Computer Science, pp. 303\u2013314, Springer .\n\n\nAlexandre Popoff, Carlos Agon, Moreno Andreatta, Andr\u00e9e Ehresmann: From K-nets to PK-nets: a Categorical Approach, Perspectives of New Music, 54(2), pp. 5\u201363, (2016).\n\n\nAlexandre Popoff, Moreno Andreatta, Andr\u00e9e Ehresmann: Relational poly-Klumpenhouwer networks for transformational and voice-leading analysis, Journal of Mathematics and Music, 12:1 (2018), pp. 35-55, DOI: 10.1080/17459737.2017.1406011.\n\n\n\n\nKNet\n\n\nopycleid.knetanalysis.PKNet(context_action)\n\n\n\n\nInstantiates a new poly-Klumpenhouwer network (PK-Net) as defined above.\nThe argument \ncontext_action\n is an instance of \nopycleid.categoryaction.CategoryAction\n and defines the \ncontext action\n of the PK-Net.\n\n\n\n\nMethods\n\n\nset_edges\n\n\nset_edges(list_edges)\n\n\n\n\nDefines the generating edges of the PK-Net.\n\n\nDefines the list of vertices for this K-Net. The argument \nlist_edges\n is a list of instances of \nopycleid.categoryaction.CatMorphism\n, each one representing a generating morphism for the \n'diagram' category action\n. Objects need not be specified, as they will be automatically extracted from the list of morphisms.\n\n\n\n\nset_mappings\n\n\nset_mappings(edges_map,elements_map)\n\n\n\n\nDefines the category action functor through the mapping of the edges and of the elements of the diagram action. The method will raise exceptions if the edge or elements mapping are not valid. The arguments are as follows.\n\n\n\n\n\n\nedges_map\n : a dictionary, the keys of which are the names of the edges (i.e. the generating morphisms of the diagram action), the values of which are the names of morphisms in the context action.\n\n\n\n\n\n\nelements_map\n : a dictionary, the keys of which are the names of the elements in the objects of the diagram action, the values of which are lists of elements names in the objects of the context action. The method will automatically build the components of the natural transformation of the category action functor. Each component must be left total, an exception will be raised otherwise.\n\n\n\n\n\n\n\n\nget_edge_mapping\n\n\nget_edge_mapping()\n\n\n\n\nReturns the mapping of \nall\n edges in the diagram action as a dictionary, the keys of which are morphism names in the diagram action, the values of which are the names of the image morphisms in the context action by the category functor of the category action functor which defines this PK-Net.\n\n\n\n\nget_elements_mapping\n\n\nget_elements_mapping()\n\n\n\n\nReturns the mapping of all elements in the diagram action as a dictionary, the keys of which are element names in the objects of the diagram action, the values of which are the names of the image elements in the context action by the natural transformation of the category action functor which defines this PK-Net.\n\n\n\n\nfrom_progression\n\n\nfrom_progression(elements)\n\n\n\n\nFrom a list \nelements\n of \n n \n element names in the context action, yields all PK-Nets with a diagram action built on the ordinal \n n \n category, i.e. all PK-Nets with \n n \n objects and \n n-1 \n edges, each edge \n f_i \n corresponding to a transformation in the context action between \nelements[i]\n and \nelements[i+1]\n. Raises an exception if no transformation exists between consecutive elements.\n\n\n\n\nglobal_transform\n\n\nglobal_transform(cat_action_functor)\n\n\n\n\nApply complete homography, i.e. a category action functor \ncat_action_functor\n (an instance of \nopycleid.categoryaction.CategoryActionFunctor\n and returns the corresponding new PK-Net. This new PK-Net has\n\n\n\n\nthe same diagram action,\n\n\na context action which corresponds to the target category action of \ncat_action_functor\n, and\n\n\na category action functor which is the product of the initial category action functor by \ncat_action_functor\n.\n\n\n\n\n\n\nlocal_transform\n\n\nlocal_transform(cat_functor,local_dict)\n\n\n\n\nApply a local homography, defined by the instance \ncat_functor\n of \nopycleid.categoryaction.CategoryFunctor\n (which should be an automorphism) and \nlocal_dict\n, and returns the corresponding new PK-Net. The argument \nlocal_dict\n defines the natural transformations \n \\tilde{\\nu} \n between functors \n F \\colon \\Delta \\to \\mathbf{C} \n and \n NF \\colon \\Delta \\to \\mathbf{C'} \n (N being defined by \ncat_functor\n). Its keys are objects names in the diagram category action, its values are morphism names in the context category action.\n\n\nReturns a new PK-Net\n\n\n\n\nwith the same diagram action and context action, and\n\n\nwhose category action functor is the product of the initial category action functor by the image by S of the natural transformation defined by \nlocal_dict\n.\n\n\n\n\nRaises an exception if local_dict does not define a valid natural transformation, or if \ncat_functor\n is not an automorphism.\n\n\n\n\nstr\n\n\nOverloads Python \nstr\n to return a string description of the PK_Net.\nReturns a description of the PK-Net which lists for each edge its name, its source and target, and the corresponding maps between elements, expressed as their image in the context action.",
            "title": "opycleid.knetanalysis"
        },
        {
            "location": "/knetanalysis/#opycleidknetanalysis",
            "text": "",
            "title": "opycleid.knetanalysis"
        },
        {
            "location": "/knetanalysis/#overview",
            "text": "This module defines a class for performing Klumpenhouwer network (K-Net) and poly-Klumpenhouwer network (PK-Net) analysis.  Informally, a K-Net is a directed graph, the vertices of which are labelled with musical objects,\nand the arrows of which are labelled with transformations between them. Arrows are understood to be composable: the label\nof a resulting composite arrow should be equal to the label of the composition of the two original arrows.  A K-Net allows one to study the interconnections between different musical elements, for example in the study of the different intervals in the constitutive elements of chords in post-tonal music.  Recent research (see below) has proposed new categorical formalizations of the K-Net notion, in which a K-Net can be conceived as the data   (R,S,F,\\phi)   of   a lax functor   R \\colon \\Delta \\to \\mathbf{Rel}  , called the  diagram action ,  a functor   S \\colon \\mathbf{C} \\to \\mathbf{Rel}   where   \\mathbf{C}   is a finite category called the  context action , and  a category action morphism   (F, \\phi)   between them, i.e. a functor   F \\colon \\Delta \\to \\mathbf{C}  , and a lax natural transformation   \\phi \\colon R \\to SF   (left-total on all components).   Complete  and  local  homographies allow to transform PK-Nets into one another. More precisely,   Complete homographies correspond to category action morphisms   (N, \\nu)   between functors   S \\colon \\mathbf{C} \\to \\mathbf{Rel}   and   S' \\colon \\mathbf{C'} \\to \\mathbf{Rel}   and yield the new PK-Net   (R,S',F'=NF,\\phi'=\\nu \\circ \\phi)  .  Local homographies correspond to the data   N, \\tilde{\\nu}   of a functor   N \\colon \\mathbf{C} \\to \\mathbf{C'}   and a natural transformations   \\tilde{\\nu}   between functors   F \\colon \\Delta \\to \\mathbf{C}   and   NF \\colon \\Delta \\to \\mathbf{C'}  , which yields the new PK-Net   (R,S',F'=NF,\\phi'=S\\tilde{\\nu} \\circ \\phi)  .",
            "title": "Overview"
        },
        {
            "location": "/knetanalysis/#references",
            "text": "Reference literature on Klumpenhouwer networks:   David Lewin: Klumpenhouwer Networks and Some Isographies That Involve Them, Music Theory Spectrum, Vol. 12, pp. 83\u2013120, (1990).  David Lewin: A Tutorial on Klumpenhouwer Networks, Using the Chorale in Schoenberg\u2019s Opus 11, No. 2, Journal of Music Theory, Vol. 38, pp. 79\u2013101, (1994).  Henri Klumpenhouwer: The Inner and Outer Automorphisms of Pitch-Class Inversion and Transposition: Some Implications for Analysis with Klumpenhouwer Networks, Int\u00e9gral, Vol. 12, pp. 81\u201393, (1998).   Categorical approaches to Klumpenhouwer networks:   Guerino Mazzola, Moreno Andreatta: From a Categorical Point of View: K-Nets as Limit Denotators, Perspectives of New Music, 44(2), pp. 88\u2013113, (2006).  Alexandre Popoff, Moreno Andreatta, Andr\u00e9e Ehresmann: A Categorical Generalization of Klumpenhouwer Networks, Proceedings of MCM 2015, Vol. 9110 of Lecture Notes in Computer Science, pp. 303\u2013314, Springer .  Alexandre Popoff, Carlos Agon, Moreno Andreatta, Andr\u00e9e Ehresmann: From K-nets to PK-nets: a Categorical Approach, Perspectives of New Music, 54(2), pp. 5\u201363, (2016).  Alexandre Popoff, Moreno Andreatta, Andr\u00e9e Ehresmann: Relational poly-Klumpenhouwer networks for transformational and voice-leading analysis, Journal of Mathematics and Music, 12:1 (2018), pp. 35-55, DOI: 10.1080/17459737.2017.1406011.",
            "title": "References"
        },
        {
            "location": "/knetanalysis/#knet",
            "text": "opycleid.knetanalysis.PKNet(context_action)  Instantiates a new poly-Klumpenhouwer network (PK-Net) as defined above.\nThe argument  context_action  is an instance of  opycleid.categoryaction.CategoryAction  and defines the  context action  of the PK-Net.",
            "title": "KNet"
        },
        {
            "location": "/knetanalysis/#methods",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/knetanalysis/#set_edges",
            "text": "set_edges(list_edges)  Defines the generating edges of the PK-Net.  Defines the list of vertices for this K-Net. The argument  list_edges  is a list of instances of  opycleid.categoryaction.CatMorphism , each one representing a generating morphism for the  'diagram' category action . Objects need not be specified, as they will be automatically extracted from the list of morphisms.",
            "title": "set_edges"
        },
        {
            "location": "/knetanalysis/#set_mappings",
            "text": "set_mappings(edges_map,elements_map)  Defines the category action functor through the mapping of the edges and of the elements of the diagram action. The method will raise exceptions if the edge or elements mapping are not valid. The arguments are as follows.    edges_map  : a dictionary, the keys of which are the names of the edges (i.e. the generating morphisms of the diagram action), the values of which are the names of morphisms in the context action.    elements_map  : a dictionary, the keys of which are the names of the elements in the objects of the diagram action, the values of which are lists of elements names in the objects of the context action. The method will automatically build the components of the natural transformation of the category action functor. Each component must be left total, an exception will be raised otherwise.",
            "title": "set_mappings"
        },
        {
            "location": "/knetanalysis/#get_edge_mapping",
            "text": "get_edge_mapping()  Returns the mapping of  all  edges in the diagram action as a dictionary, the keys of which are morphism names in the diagram action, the values of which are the names of the image morphisms in the context action by the category functor of the category action functor which defines this PK-Net.",
            "title": "get_edge_mapping"
        },
        {
            "location": "/knetanalysis/#get_elements_mapping",
            "text": "get_elements_mapping()  Returns the mapping of all elements in the diagram action as a dictionary, the keys of which are element names in the objects of the diagram action, the values of which are the names of the image elements in the context action by the natural transformation of the category action functor which defines this PK-Net.",
            "title": "get_elements_mapping"
        },
        {
            "location": "/knetanalysis/#from_progression",
            "text": "from_progression(elements)  From a list  elements  of   n   element names in the context action, yields all PK-Nets with a diagram action built on the ordinal   n   category, i.e. all PK-Nets with   n   objects and   n-1   edges, each edge   f_i   corresponding to a transformation in the context action between  elements[i]  and  elements[i+1] . Raises an exception if no transformation exists between consecutive elements.",
            "title": "from_progression"
        },
        {
            "location": "/knetanalysis/#global_transform",
            "text": "global_transform(cat_action_functor)  Apply complete homography, i.e. a category action functor  cat_action_functor  (an instance of  opycleid.categoryaction.CategoryActionFunctor  and returns the corresponding new PK-Net. This new PK-Net has   the same diagram action,  a context action which corresponds to the target category action of  cat_action_functor , and  a category action functor which is the product of the initial category action functor by  cat_action_functor .",
            "title": "global_transform"
        },
        {
            "location": "/knetanalysis/#local_transform",
            "text": "local_transform(cat_functor,local_dict)  Apply a local homography, defined by the instance  cat_functor  of  opycleid.categoryaction.CategoryFunctor  (which should be an automorphism) and  local_dict , and returns the corresponding new PK-Net. The argument  local_dict  defines the natural transformations   \\tilde{\\nu}   between functors   F \\colon \\Delta \\to \\mathbf{C}   and   NF \\colon \\Delta \\to \\mathbf{C'}   (N being defined by  cat_functor ). Its keys are objects names in the diagram category action, its values are morphism names in the context category action.  Returns a new PK-Net   with the same diagram action and context action, and  whose category action functor is the product of the initial category action functor by the image by S of the natural transformation defined by  local_dict .   Raises an exception if local_dict does not define a valid natural transformation, or if  cat_functor  is not an automorphism.",
            "title": "local_transform"
        },
        {
            "location": "/knetanalysis/#str",
            "text": "Overloads Python  str  to return a string description of the PK_Net.\nReturns a description of the PK-Net which lists for each edge its name, its source and target, and the corresponding maps between elements, expressed as their image in the context action.",
            "title": "str"
        }
    ]
}