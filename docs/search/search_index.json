{
    "docs": [
        {
            "location": "/",
            "text": "Opycleid: The Python library for transformational music analysis\n\n\nWelcome to Opycleid\n\n\nOpycleid is a Python library for \ntransformational music analysis (TMT)\n, a field of musicology\nwhich studies transformations between musical objects (notes, chords, durations, etc.)\nfrom a mathematical point of view. This field was initiated by David Lewin in the 1980s, relying mainly\non mathematical group theory, and later developed and extended using elements of \ncategory theory\n.\n\n\nThe use of this library assumes that one is familiar with the basic notions in transformational music theory.\nHere are a few links for those who would be interested in discovering this subject.\n\n\n\n\nThe \nWikipedia page\n on the subject.\n\n\nA \nseries of blog posts introducing transformational music theory\n.\n\n\nThe book of David Lewin, where he first defined its group-theoretical approach of \ngeneralized musical intervals\n: Lewin, D.: Generalized Musical Intervals and Transformations, Yale University Press: New Haven, CT, 1987.\n\n\n\n\n\n\nGuiding principles\n\n\n\n\nUser-friendly\n: Opycleid provides ready-to-use classes for the common groups and monoids encountered in TMT, such as the \n T\\text{/}I \n group or the \n \\text{PRL} \n group usually found in neo-Riemannian theory. These classes provides methods for determining, multiplying, and applying musical transformations. For, one can start analyzing chords in just a few lines of Python, as shown below.\n\n\n\n\nfrom opycleid.musicmonoids import TI_Group_Triads\n\nmy_group = TI_Group_Triads()\nprint (my_group.get_operation(\nC_M\n,\nB_m\n)) ## ['I6']\nprint (my_group.apply_operation(\nI5\n,\nE_m\n)) ## ['Fs_M']\n\n\n\n\n\n\n\n\nGeneralizability\n: TMT has mainly been applied to the analysis of relations between notes and chords, but it can in fact be applied to any musical object, such as durations, time-spans, rhythms, etc. Opycleid takes a very general approach to TMT by considering \ncategory actions\n in \n \\mathbf{Rel} \n, i.e. faithful functors from a small category to the 2-category \n \\mathbf{Rel} \n of finite sets and relations between them. The elements of these sets are specified as strings and can represent any musical object.\n\n\n\n\n\n\nCustomizability\n: though the usual musical groups and monoids are already implemented in Opycleid, custom monoids can be generated by specifying objects and morphisms. Their definition is made easy by the use of standard Python primitives (dictionaries and lists).\n\n\n\n\n\n\nWhat it is not\n: to allow the user to define his own category actions, Opycleid implements some routines which can be found in computer algebra systems such as GAP and SageMath. However, Opycleid is focused on musical applications, and is therefore not meant to be as complete as these softwares. In particular, Opycleid does not fully implement category theory (categories, functors, natural transformations, etc.), but focuses on faithful functors to \n \\mathbf{Rel} \n, which can be more easily implemented.\n\n\n\n\n\n\n\n\nUser installation\n\n\nThe easiest way to install Opycleid is using \npip\n:\n\n\n$ pip install opycleid\n\n\n\nOpycleid can also be installed directly from source:\n\n\n$ python setup.py install\n\n\n\n\n\nSupport\n\n\nBug reports and features requests (only)\n can be posted in \nGitHub issues\n.\n\n\n\n\nWhy this name, Opycleid ?\n\n\nThe \nophicleide\n is a keyed brass instrument from the 19th century.\nFrom the greek ophis (\u1f44\u03c6\u03b9\u03c2) \"serpent\" (hence the perfect name for a Python library) + kleis (\u03ba\u03bb\u03b5\u03af\u03c2) \"keys\", it means a serpent with keys, the \nserpent\n being an older instrument it evolved from.\n\n\n\n\nThe ophicleide was later superseded by the tuba, which was considered more reliable in terms of tone production.",
            "title": "Home"
        },
        {
            "location": "/#opycleid-the-python-library-for-transformational-music-analysis",
            "text": "",
            "title": "Opycleid: The Python library for transformational music analysis"
        },
        {
            "location": "/#welcome-to-opycleid",
            "text": "Opycleid is a Python library for  transformational music analysis (TMT) , a field of musicology\nwhich studies transformations between musical objects (notes, chords, durations, etc.)\nfrom a mathematical point of view. This field was initiated by David Lewin in the 1980s, relying mainly\non mathematical group theory, and later developed and extended using elements of  category theory .  The use of this library assumes that one is familiar with the basic notions in transformational music theory.\nHere are a few links for those who would be interested in discovering this subject.   The  Wikipedia page  on the subject.  A  series of blog posts introducing transformational music theory .  The book of David Lewin, where he first defined its group-theoretical approach of  generalized musical intervals : Lewin, D.: Generalized Musical Intervals and Transformations, Yale University Press: New Haven, CT, 1987.",
            "title": "Welcome to Opycleid"
        },
        {
            "location": "/#guiding-principles",
            "text": "User-friendly : Opycleid provides ready-to-use classes for the common groups and monoids encountered in TMT, such as the   T\\text{/}I   group or the   \\text{PRL}   group usually found in neo-Riemannian theory. These classes provides methods for determining, multiplying, and applying musical transformations. For, one can start analyzing chords in just a few lines of Python, as shown below.   from opycleid.musicmonoids import TI_Group_Triads\n\nmy_group = TI_Group_Triads()\nprint (my_group.get_operation( C_M , B_m )) ## ['I6']\nprint (my_group.apply_operation( I5 , E_m )) ## ['Fs_M']    Generalizability : TMT has mainly been applied to the analysis of relations between notes and chords, but it can in fact be applied to any musical object, such as durations, time-spans, rhythms, etc. Opycleid takes a very general approach to TMT by considering  category actions  in   \\mathbf{Rel}  , i.e. faithful functors from a small category to the 2-category   \\mathbf{Rel}   of finite sets and relations between them. The elements of these sets are specified as strings and can represent any musical object.    Customizability : though the usual musical groups and monoids are already implemented in Opycleid, custom monoids can be generated by specifying objects and morphisms. Their definition is made easy by the use of standard Python primitives (dictionaries and lists).    What it is not : to allow the user to define his own category actions, Opycleid implements some routines which can be found in computer algebra systems such as GAP and SageMath. However, Opycleid is focused on musical applications, and is therefore not meant to be as complete as these softwares. In particular, Opycleid does not fully implement category theory (categories, functors, natural transformations, etc.), but focuses on faithful functors to   \\mathbf{Rel}  , which can be more easily implemented.",
            "title": "Guiding principles"
        },
        {
            "location": "/#user-installation",
            "text": "The easiest way to install Opycleid is using  pip :  $ pip install opycleid  Opycleid can also be installed directly from source:  $ python setup.py install",
            "title": "User installation"
        },
        {
            "location": "/#support",
            "text": "Bug reports and features requests (only)  can be posted in  GitHub issues .",
            "title": "Support"
        },
        {
            "location": "/#why-this-name-opycleid",
            "text": "The  ophicleide  is a keyed brass instrument from the 19th century.\nFrom the greek ophis (\u1f44\u03c6\u03b9\u03c2) \"serpent\" (hence the perfect name for a Python library) + kleis (\u03ba\u03bb\u03b5\u03af\u03c2) \"keys\", it means a serpent with keys, the  serpent  being an older instrument it evolved from.   The ophicleide was later superseded by the tuba, which was considered more reliable in terms of tone production.",
            "title": "Why this name, Opycleid ?"
        },
        {
            "location": "/gettingstarted/",
            "text": "A tutorial on Opycleid\n\n\nWe give here a quick tutorial on the major features of Opycleid. Please consult the reference manual for a detailed description of the classes and methods.\n\n\nUsing existing category actions\n\n\nIn simple cases, one would just like to analyze chords, notes, etc. using the groups and monoids commonly used in transformational music theory, such as the transposition/inversion group, also known as the \n T\\text{/}I \n group, or the neo-Riemannian \n \\text{PRL} \n group.\n\n\nOpycleid provides ready-to-use groups and monoids to perform such analysis. Let's take a famous example, first introduced by Richard Cohn (\nRichard Cohn: Maximally Smooth Cycles, Hexatonic Systems, and the Analysis of Late-Romantic Triadic Progressions, Music Analysis, 15(1), pp. 9-40, (1996).\n), namely the second movement of Beethoven's Ninth Symphony at bar 143. This is a progression of 19 major and minor triads, starting with C major, A minor, F major, D minor, B flat major, etc.\n\n\nWe would like to analyze this progression using the \n \\text{PRL} \n group. First, we create a new instance of \nopycleid.musicmonoids.PRL_Group\n.\n\n\nfrom opycleid.musicmonoids import PRL_Group\n\nmy_group = PRL_Group()\n\n\n\n\nThe class \nopycleid.musicmonoids.PRL_Group\n inherits from \nopycleid.categoryaction.MonoidAction\n, which itself inherits from \nopycleid.categoryaction.CategoryAction\n. This latter class is the basis for all category actions, and provides three methods, \nmult\n, \napply_operation\n, and \nget_operation\n for respectively composing musical transformations, applying a musical transformation to a musical element, and getting the possible transformations between two musical elements.\nIn our case, we would like to determine which operation from the \n \\text{PRL} \n group takes C major to A minor, A minor to F major, F major to D minor, and so on. This is achieved in one line in Python by calling the method \nget_operation\n.\n\n\nprint(my_group.get_operation(\nC_M\n,\nA_m\n)) ## prints ['R']\nprint(my_group.get_operation(\nA_m\n,\nF_M\n)) ## prints ['L]\nprint(my_group.get_operation(\nF_M\n,\nD_m\n)) ## prints ['R']\nprint(my_group.get_operation(\nD_m\n,\nBb_M\n)) ## prints ['L']\n\n\n\n\nWe see here that the Beethoven progression is built on a \n R-L \n cycle.\n\n\nTo compare, we could analyze the same progression using the \n T\\text{/}I \n group, which is also implemented in Opycleid.\n\n\nfrom opycleid.musicmonoids import TI_Group_Triads\n\nmy_group = TI_Group_Triads()\n\nprint(my_group.get_operation(\nC_M\n,\nA_m\n)) ## prints ['I4']\nprint(my_group.get_operation(\nA_m\n,\nF_M\n)) ## prints ['I9']\nprint(my_group.get_operation(\nF_M\n,\nD_m\n)) ## prints ['I2']\nprint(my_group.get_operation(\nD_m\n,\nBb_M\n)) ## prints ['I7']\n\n\n\n\nComing back to the \n \\text{PRL} \n group, we could wonder what would yield the transformation \n R \n applied to the G minor triad. This is achieved by calling the method \napply_operation\n.\n\n\nfrom opycleid.musicmonoids import PRL_Group\n\nmy_group = PRL_Group()\nprint(my_group.apply_operation(\nR\n,\nG_m\n)) ## prints ['Bb_M']\n\n\n\n\nFinally, we can multiply operations by calling \nmult\n.\n\n\nfrom opycleid.musicmonoids import PRL_Group\n\nmy_group = PRL_Group()\nprint(my_group.mult(\nRPL\n,\nR\n)) ## prints ['LP']\n\n\n\n\nnote: depending on your configuration, the names of the operations in the monoid might be different, although they represent the same transformation.\n\n\nDefining custom morphisms and category actions\n\n\nIf the ready-to-use monoids and groups provided by Opycleid are not enough, it is possible to create one's own category action for specific musical purposes.\nIn this section, we will see how to build morphisms and generate a category from them.\n\n\nIn our example use case, we would like to study major and augmented triads, and transformations between them. Instead of considering all triads in a single set, we are going to consider two distinct sets: one with the 12 major triads, which we denote by \n X=\\{C_M, C\\sharp_M, D_M, E\\flat_M, E_M, F_M, F\\sharp_M, G_M, G\\sharp_M, A_M, B\\flat_M, B_M\\} \n, and one with the 4 augmented triads, which we denote by \n Y=\\{C_{\\text{aug}}, F_{\\text{aug}}, D_{\\text{aug}}, G_{\\text{aug}}\\} \n.\n\n\nFirst, we need to define these category objects in Opycleid, by instantiating the class \nopycleid.categoryaction.CatObject\n\n\nfrom opycleid.categoryaction import CatObject\n\nX = CatObject(\nX\n,[\nC_M\n,\nCs_M\n,\nD_M\n,\nEb_M\n,\nE_M\n,\n                   \nF_M\n,\nFs_M\n,\nG_M\n,\nGs_M\n,\nA_M\n,\n                   \nBb_M\n,\nB_M\n])\nY = CatObject(\nY\n,[\nC_aug\n,\nF_aug\n,\nD_aug\n,\nG_aug\n])\n\n\n\n\nCaution: all elements should have distinct names (even across distinct objects). If not, this may lead to random and unexpected behavior.\n\n\nThen, we are going to define some morphisms of interest. The first one is simply the transposition operator acting on the set of the 12 major triads, which send \nC\n major to \nC\\sharp\n major, \nC\\sharp\n major to \nD\n major, and so on. In Opycleid, we need to instantiate the class \nopycleid.categoryaction.CatMorphism\n and define the action of this morphism on its domain.\n\n\nfrom opycleid.categoryaction import CatMorphism\n\n## We create a category morphism with name \nT\n, domain X, and codomain X\nT = CatMorphism(\nT\n,X,X)\nT.set_mapping({\nC_M\n:[\nCs_M\n],\nCs_M\n:[\nD_M\n],\nD_M\n:[\nEb_M\n],\nEb_M\n:[\nE_M\n],\n               \nE_M\n:[\nF_M\n],\nF_M\n:[\nFs_M\n],\nFs_M\n:[\nG_M\n],\nG_M\n:[\nGs_M\n],\n               \nGs_M\n:[\nA_M\n],\nA_M\n:[\nBb_M\n],\nBb_M\n:[\nB_M\n],\nB_M\n:[\nC_M\n]})\n\n\n\n\nAny instance of \nopycleid.categoryaction.CatMorphism\n overloads the \n Python operator in order to denote the action of a morphism on an element of its domain.\nFor example, if we would like to know what is the image of \nF\n major by the morphism \nT\n, we would write the following.\n\n\nprint(T\nF_M\n) ## prints ['Fs_M']\n\n\n\n\nInstances of \nopycleid.categoryaction.CatMorphism\n can be composed if their domain and codomain are compatible. For example, the composition of \nT\n with itself gives, as expected, a transposition operator which moves the root of a major triad by two semitones.\n\n\nT_2 = T*T\nprint(T_2\nF_M\n) ## prints ['G_M']\n\n\n\n\nAs we will see later, there is no need to explicitly calculate all possible compositions of morphisms. Instead, \ngenerators\n will be specified in a category, and Opycleid itself will generate the whole category.\n\n\nSince we want to study transformations between major triads and augmented triads, we are going to define another morphism with domain \nX\n and codomain \nY\n. Observe that, for any major triad, we get an augmented triad if the fifth is raised a semitone higher. This will define our second morphism, and since names can even be unicode strings, we will call it \u540c.\n\n\n## We create a category morphism with name \n\u540c\n, domain X, and codomain Y\nI = CatMorphism(u\n\u540c\n,X,Y)\nI.set_mapping({\nC_M\n:[\nC_aug\n],\nCs_M\n:[\nF_aug\n],\nD_M\n:[\nD_aug\n],\nEb_M\n:[\nG_aug\n],\n               \nE_M\n:[\nC_aug\n],\nF_M\n:[\nF_aug\n],\nFs_M\n:[\nD_aug\n],\nG_M\n:[\nG_aug\n],\n               \nGs_M\n:[\nC_aug\n],\nA_M\n:[\nF_aug\n],\nBb_M\n:[\nD_aug\n],\nB_M\n:[\nG_aug\n]})\n\n\n\n\nCaution: all morphisms in a category should have distinct names. If not, this may lead to random and unexpected behavior.\n\n\nConversely, if one lowers any note of an augmented triad by a semitone, one gets a major triad. Since, there are three possible notes, this defines a relation (and not simply a function) from \nY\n to \nX\n. We will call this morphism \u548c.\n\n\n## We create a category morphism with name \n\u548c\n, domain Y, and codomain X\nJ = CatMorphism(u\n\u548c\n,Y,X)\nJ.set_mapping({\nC_aug\n:[\nC_M\n,\nE_M\n,\nGs_M\n],\n               \nF_aug\n:[\nCs_M\n,\nF_M\n,\nA_M\n],\n               \nD_aug\n:[\nD_M\n,\nFs_M\n,\nBb_M\n],\n               \nG_aug\n:[\nEb_M\n,\nG_M\n,\nB_M\n]})\n\n\n\n\nWe now create the category generated by the two objects \nX\n and \nY\n, and the three morphisms \nT\n, \u540c, and \u548c. For this, we instantiate \nopycleid.categoryaction.CategoryAction\n and specify the objects and the generators.\n\n\nfrom opycleid.categoryaction import CategoryAction\n\nmy_category = CategoryAction()\nmy_category.set_objects([X,Y])\nmy_category.add_generators([T,I,J])\nmy_category.generate_category()\nfor name_f,f in my_category.get_morphisms():\n  print(name_f)\n'''\nThis prints the following list:\nT\nTT\nTTT\nTTTT\nTTTTT\nTTTTTT\nTTTTTTT\nTTTTTTTT\nTTTTTTTTT\nTTTTTTTTTT\nTTTTTTTTTTT\nTTT\u548c\nTT\u548c\nT\u548c\nid_X\nid_Y\n\u540c\n\u540cT\n\u540cTT\n\u540cTTT\n\u540cTTT\u548c\n\u540cTT\u548c\n\u540cT\u548c\n\u548c\n\u548c\u540c\n\u548c\u540cT\n\u548c\u540cTT\n\u548c\u540cTTT\n'''  \n\n\n\n\nDuring the generation process, the names are obtained by concatenation. We can ask Opycleid to rewrite these operations.\n\n\nmy_category.rewrite_operations()\nfor name_f,f in my_category.get_morphisms():\n  print(name_f)\n'''\nThis prints the following list:\n(T^10)\n(T^11)\n(T^2)\n(T^2)\u548c\n(T^3)\n(T^3)\u548c\n(T^4)\n(T^5)\n(T^6)\n(T^7)\n(T^8)\n(T^9)\nT\nT\u548c\nid_X\nid_Y\n\u540c\n\u540c(T^2)\n\u540c(T^2)\u548c\n\u540c(T^3)\n\u540c(T^3)\u548c\n\u540cT\n\u540cT\u548c\n\u548c\n\u548c\u540c\n\u548c\u540c(T^2)\n\u548c\u540c(T^3)\n\u548c\u540cT\n'''\n\n\n\n\n(Depending on your operating system, the name of the operations above might not be the same, but the relations they represent are)\n\n\nNote:\n the rewriting process of Opycleid is very basic, and only tries to identify repeated consecutive sequences of generators names.\n\n\nOur category is such that\n\n\n\n\nThere are 16 morphisms from \nX\n to \nX\n:\n\n\n12 of the form \nT^p\n with \np=0\\ldots11\n (\nT^0\n being \n\\text{id_X}\n), and\n\n\n4 of the form \nT^p\u548c\u540c\n with \np=0\\ldots3\n (here \u548c\u540c(T^3), \u548c\u540c(T^2), \u548c\u540cT, and \u548c\u540c, since \nT^p\u548c\u540c=\u548c\u540cT^p\n as can be verified directly in Opycleid).\n\n\n\n\n\n\nThere are 4 morphisms from \nY\n to \nY\n:\n\n\nof the form \n\u540cT^p\u548c\n with \np=0\\ldots3\n (\n\u540c\u548c\n being equal to \n\\text{id_Y}\n)\n\n\n\n\n\n\nThere are 4 morphisms from \nX\n to \nY\n:\n\n\nof the form \n\u540cT^p\n with \np=0\\ldots3\n\n\n\n\n\n\n\n\nThere are 4 morphisms from \nY\n to \nX\n:\n\n\nof the form \nT^p\u548c\n with \np=0\\ldots3\n\n\n\n\n\n\n\n\n\n\nNow that our category is generated, we can use it for analyzing transformations between chords.\nFor example, we could ask what are the transformations between \nE\n major and \nA\n major.\n\n\nprint(my_category.get_operation(\nE_M\n,\nA_M\n))\n## Prints ['(T^5)', '\u548c\u540cT']\n\n\n\n\nIndeed we can just transpose \nE\n major by five semitone higher, using \nT^{5}\n, or we can transform \nE\n major to \nC\n augmented using \u540c, then to \nG\\sharp\n major by using \u548c, and finally to \nA\n major by using \nT\n.\n\n\nDefining monoid action morphisms\n\n\nIn the framework of Opycleid, an instance of \nopycleid.categoryaction.CategoryAction\n is a concrete implementation of a faithful functor \n S \\colon \\mathbf{C} \\to \\mathbf{Rel} \n,\nwhere \n \\mathbf{C} \n is a small category, and \n \\mathbf{Rel} \n is the 2-category of finite sets and relations. Such a functor defines a \"context\" for the analysis: in the example above, we worked in the set of the major and minor triads, or in the two distinct sets of major triads and augmented triads.\n\n\nIt is naturally to ask whether an analysis context can be changed. This is the role of \ncategory action morphisms\n. By definition, a morphism between two category actions \n S \\colon \\mathbf{C} \\to \\mathbf{Rel} \n and \n S' \\colon \\mathbf{C'} \\to \\mathbf{Rel} \n is a pair \n (N,\\nu) \n where\n\n\n\n\n\n\n N \n is a functor from \n \\mathbf{C} \n to \n \\mathbf{C'} \n, and\n\n\n\n\n \\nu \n is a lax natural transformation from \n S \n to \n S'N \n.\n\n\n\n\nWhen \n \\mathbf{C} \n and \n \\mathbf{C'} \n are monoids, the natural transformation \n \\nu \n is simply a morphism in \n \\mathbf{Rel} \n (i.e. a relation)\nbetween the sets \n S(e) \n and \n S'(e') \n (\ne\n and \ne'\n being the single objects of \n \\mathbf{C} \n and \n \\mathbf{C'} \n),\nsuch that for any morphism \n f \n of \n \\mathbf{C} \n the relation \n \\nu \\circ S(f) \n is included in the relation \n S'N(f) \\circ \\nu \n.\n\n\nCurrently, Opycleid only allows the definition of monoid action morphisms.\n\n\nTo illustrate the notion, consider the \n T\\text{/}I \n group introduced previously. This is an extension \n 1 \\to \\mathbb{Z}_{12} \\to T\\text{/}I \\to \\mathbb{Z}_{2} \\to 1\n, where the homomorphism \n \\pi \\colon T\\text{/}I \\to \\mathbb{Z}_{2} \n sends the transposition operations \nT^p\n to the identity of \n \\mathbb{Z}_{2} \n, whereas the inversion operations \nI^p\n are sent to the non-trivial element of \n \\mathbb{Z}_{2} \n. The group \n \\mathbb{Z}_{2} \n can be made to act on the set of \n\\{major,minor\\}\n of chord types in an obvious manner. We can are then going to build a monoid action morphism between these two monoid actions.\n\n\nFirst, we define the group \n \\mathbb{Z}_{2} \n and its action.\n\n\nfrom opycleid.categoryaction import CatObject, CatMorphism, MonoidAction\n\nS = CatObject(\nS\n,[\nmajor\n,\nminor\n])\n\nZ = CatMorphism(\nz\n,S,S)\nZ.set_mapping({\nmajor\n:[\nminor\n],\nminor\n:[\nmajor\n]})\n\nZ2_group = MonoidAction()\nZ2_group.set_objects([S])\nZ2_group.add_generators([Z])\nZ2_group.generate_category()\nfor x in Z2_group.operations:\n    print(x)\n## This prints 'z', id_S' as expected    \n\n\n\n\nWe also need to instantiate the \n T\\text{/}I \n group\n\n\nfrom opycleid.musicmonoids import TI_Group_Triads\n\nti_group = TI_Group_Triads()\n\n\n\n\nTo define the monoid action morphism, we need to define the mapping on operations (which defines the functor \nN\n), and the mapping on elements (which defines the natural transformation \n\\nu\n).\n\n\noperation_mapping={\nid_.\n:\nid_S\n,\nT1\n:\nid_S\n,\nT2\n:\nid_S\n,\nT3\n:\nid_S\n,\n                   \nT4\n:\nid_S\n,\nT5\n:\nid_S\n,\nT6\n:\nid_S\n,\nT7\n:\nid_S\n,\n                   \nT8\n:\nid_S\n,\nT9\n:\nid_S\n,\nT10\n:\nid_S\n,\nT11\n:\nid_S\n,\n                   \nI0\n:\nz\n,\nI1\n:\nz\n,\nI2\n:\nz\n,\nI3\n:\nz\n,\nI4\n:\nz\n,\n                   \nI5\n:\nz\n,\nI6\n:\nz\n,\nI7\n:\nz\n,\nI8\n:\nz\n,\nI9\n:\nz\n,\n                   \nI10\n:\nz\n,\nI11\n:\nz\n}\nelements = [\nC_M\n,\nCs_M\n,\nD_M\n,\nEb_M\n,\nE_M\n,\nF_M\n,\n            \nFs_M\n,\nG_M\n,\nGs_M\n,\nA_M\n,\nBb_M\n,\nB_M\n,\n            \nC_m\n,\nCs_m\n,\nD_m\n,\nEb_m\n,\nE_m\n,\nF_m\n,\n            \nFs_m\n,\nG_m\n,\nGs_m\n,\nA_m\n,\nBb_m\n,\nB_m\n]\nelement_mapping = {}\nfor x in elements:\n  if x[-1]==\nM\n:\n    element_mapping[x]=[\nmajor\n]\n  else:\n    element_mapping[x]=[\nminor\n]\n\n\n\n\nWe then instantiate \nopycleid.monoidactionmorphism.MonoidActionMorphism\n by specifying the source, target, and the necessary mappings.\n\n\nfrom opycleid.monoidactionmorphism import MonoidActionMorphism\n\naction_morphism = MonoidActionMorphism(ti_group,Z2_group,operation_mapping,element_mapping)\n\n\n\n\nFinally we check that our monoid action morphism is a valid one (i.e. both the functor \nN\n and the natural transformation \n\\nu\n are valid).\n\n\nprint(action_morphism.is_monoidmorphism_valid())\n## True\nprint(action_morphism.is_nattransformation_valid())\n## True\n\n## The following is a wrap-up around the successive two methods above\nprint(action_morphism.is_valid())\n## True\n\n\n\n\nK-Net analysis\n\n\nOpycleid provides the means to perform basic Klumpenhouwer network (K-Net) analysis.\n\n\nInformally, a K-Net is a directed graph, the vertices of which are labelled with musical objects,\nand the arrows of which are labelled with transformations between them. Arrows are understood to be composable: the label\nof a resulting composite arrow should be equal to the label of the composition of the two original arrows.\n\n\nA K-Net allows one to study the interconnections between different musical elements,\nfor example in the study of the different intervals in the constitutive elements of chords in post-tonal music.\n\n\nOpycleid proposes a simplified version of this approach, by focusing on networks using monoid actions, in which vertices are labelled with singletons.\nTo illustrate this, we go back to the Beethoven example above, and create a K-net from the chord progression. We need to instantiate \nopycleid.knetanalysis.KNet\n by\nspecifying a monoid action, in our case the \n T\\text{/}I \n group.\n\n\nfrom opycleid.musicmonoids import TI_Group_Triads\n\nti_group = TI_Group_Triads()\n\nfrom opycleid.knetanalysis import KNet\n\nmy_knet = KNet(ti_group)\nmy_knet.set_vertices([\nC_M\n,\nA_m\n,\nF_M\n,\nD_m\n,\nBb_M\n])\n\n\n\n\nSince the \n T\\text{/}I \n group is simply transitive, the determination of the musical transformations between the vertices is unambiguous, so we can call \npath_knet_from_vertices()\n to automatically determine them. Otherwise, edges have to be manually specified.\n\n\nmy_knet.path_knet_from_vertices()\nprint(str(my_knet))\n'''\nK-Net description:\n       I4   \n    C_M--\nA_m\n       I9   \n    A_m--\nF_M\n       I2   \n    F_M--\nD_m\n       I7    \n    D_m--\nBb_M\n'''\n\n\n\n\nFinally, we can transform a K-net into another by using a monoid action morphism. If we use the monoid action morphism we defined in the previous section, we get the following new K-net.\n\n\nnew_knet = my_knet.apply_knet_morphism(action_morphism)\nprint(str(new_knet))\n'''\nK-Net description:\n         z     \n    major-\nminor\n         z     \n    minor-\nmajor\n         z     \n    major-\nminor\n         z     \n    minor-\nmajor\n'''\n\n\n\n\nAs expected, we have transformed our original K-net describing chords and their transformations to a new K-net describing \nchord types\n and their transformations.",
            "title": "Tutorial"
        },
        {
            "location": "/gettingstarted/#a-tutorial-on-opycleid",
            "text": "We give here a quick tutorial on the major features of Opycleid. Please consult the reference manual for a detailed description of the classes and methods.",
            "title": "A tutorial on Opycleid"
        },
        {
            "location": "/gettingstarted/#using-existing-category-actions",
            "text": "In simple cases, one would just like to analyze chords, notes, etc. using the groups and monoids commonly used in transformational music theory, such as the transposition/inversion group, also known as the   T\\text{/}I   group, or the neo-Riemannian   \\text{PRL}   group.  Opycleid provides ready-to-use groups and monoids to perform such analysis. Let's take a famous example, first introduced by Richard Cohn ( Richard Cohn: Maximally Smooth Cycles, Hexatonic Systems, and the Analysis of Late-Romantic Triadic Progressions, Music Analysis, 15(1), pp. 9-40, (1996). ), namely the second movement of Beethoven's Ninth Symphony at bar 143. This is a progression of 19 major and minor triads, starting with C major, A minor, F major, D minor, B flat major, etc.  We would like to analyze this progression using the   \\text{PRL}   group. First, we create a new instance of  opycleid.musicmonoids.PRL_Group .  from opycleid.musicmonoids import PRL_Group\n\nmy_group = PRL_Group()  The class  opycleid.musicmonoids.PRL_Group  inherits from  opycleid.categoryaction.MonoidAction , which itself inherits from  opycleid.categoryaction.CategoryAction . This latter class is the basis for all category actions, and provides three methods,  mult ,  apply_operation , and  get_operation  for respectively composing musical transformations, applying a musical transformation to a musical element, and getting the possible transformations between two musical elements.\nIn our case, we would like to determine which operation from the   \\text{PRL}   group takes C major to A minor, A minor to F major, F major to D minor, and so on. This is achieved in one line in Python by calling the method  get_operation .  print(my_group.get_operation( C_M , A_m )) ## prints ['R']\nprint(my_group.get_operation( A_m , F_M )) ## prints ['L]\nprint(my_group.get_operation( F_M , D_m )) ## prints ['R']\nprint(my_group.get_operation( D_m , Bb_M )) ## prints ['L']  We see here that the Beethoven progression is built on a   R-L   cycle.  To compare, we could analyze the same progression using the   T\\text{/}I   group, which is also implemented in Opycleid.  from opycleid.musicmonoids import TI_Group_Triads\n\nmy_group = TI_Group_Triads()\n\nprint(my_group.get_operation( C_M , A_m )) ## prints ['I4']\nprint(my_group.get_operation( A_m , F_M )) ## prints ['I9']\nprint(my_group.get_operation( F_M , D_m )) ## prints ['I2']\nprint(my_group.get_operation( D_m , Bb_M )) ## prints ['I7']  Coming back to the   \\text{PRL}   group, we could wonder what would yield the transformation   R   applied to the G minor triad. This is achieved by calling the method  apply_operation .  from opycleid.musicmonoids import PRL_Group\n\nmy_group = PRL_Group()\nprint(my_group.apply_operation( R , G_m )) ## prints ['Bb_M']  Finally, we can multiply operations by calling  mult .  from opycleid.musicmonoids import PRL_Group\n\nmy_group = PRL_Group()\nprint(my_group.mult( RPL , R )) ## prints ['LP']  note: depending on your configuration, the names of the operations in the monoid might be different, although they represent the same transformation.",
            "title": "Using existing category actions"
        },
        {
            "location": "/gettingstarted/#defining-custom-morphisms-and-category-actions",
            "text": "If the ready-to-use monoids and groups provided by Opycleid are not enough, it is possible to create one's own category action for specific musical purposes.\nIn this section, we will see how to build morphisms and generate a category from them.  In our example use case, we would like to study major and augmented triads, and transformations between them. Instead of considering all triads in a single set, we are going to consider two distinct sets: one with the 12 major triads, which we denote by   X=\\{C_M, C\\sharp_M, D_M, E\\flat_M, E_M, F_M, F\\sharp_M, G_M, G\\sharp_M, A_M, B\\flat_M, B_M\\}  , and one with the 4 augmented triads, which we denote by   Y=\\{C_{\\text{aug}}, F_{\\text{aug}}, D_{\\text{aug}}, G_{\\text{aug}}\\}  .  First, we need to define these category objects in Opycleid, by instantiating the class  opycleid.categoryaction.CatObject  from opycleid.categoryaction import CatObject\n\nX = CatObject( X ,[ C_M , Cs_M , D_M , Eb_M , E_M ,\n                    F_M , Fs_M , G_M , Gs_M , A_M ,\n                    Bb_M , B_M ])\nY = CatObject( Y ,[ C_aug , F_aug , D_aug , G_aug ])  Caution: all elements should have distinct names (even across distinct objects). If not, this may lead to random and unexpected behavior.  Then, we are going to define some morphisms of interest. The first one is simply the transposition operator acting on the set of the 12 major triads, which send  C  major to  C\\sharp  major,  C\\sharp  major to  D  major, and so on. In Opycleid, we need to instantiate the class  opycleid.categoryaction.CatMorphism  and define the action of this morphism on its domain.  from opycleid.categoryaction import CatMorphism\n\n## We create a category morphism with name  T , domain X, and codomain X\nT = CatMorphism( T ,X,X)\nT.set_mapping({ C_M :[ Cs_M ], Cs_M :[ D_M ], D_M :[ Eb_M ], Eb_M :[ E_M ],\n                E_M :[ F_M ], F_M :[ Fs_M ], Fs_M :[ G_M ], G_M :[ Gs_M ],\n                Gs_M :[ A_M ], A_M :[ Bb_M ], Bb_M :[ B_M ], B_M :[ C_M ]})  Any instance of  opycleid.categoryaction.CatMorphism  overloads the   Python operator in order to denote the action of a morphism on an element of its domain.\nFor example, if we would like to know what is the image of  F  major by the morphism  T , we would write the following.  print(T F_M ) ## prints ['Fs_M']  Instances of  opycleid.categoryaction.CatMorphism  can be composed if their domain and codomain are compatible. For example, the composition of  T  with itself gives, as expected, a transposition operator which moves the root of a major triad by two semitones.  T_2 = T*T\nprint(T_2 F_M ) ## prints ['G_M']  As we will see later, there is no need to explicitly calculate all possible compositions of morphisms. Instead,  generators  will be specified in a category, and Opycleid itself will generate the whole category.  Since we want to study transformations between major triads and augmented triads, we are going to define another morphism with domain  X  and codomain  Y . Observe that, for any major triad, we get an augmented triad if the fifth is raised a semitone higher. This will define our second morphism, and since names can even be unicode strings, we will call it \u540c.  ## We create a category morphism with name  \u540c , domain X, and codomain Y\nI = CatMorphism(u \u540c ,X,Y)\nI.set_mapping({ C_M :[ C_aug ], Cs_M :[ F_aug ], D_M :[ D_aug ], Eb_M :[ G_aug ],\n                E_M :[ C_aug ], F_M :[ F_aug ], Fs_M :[ D_aug ], G_M :[ G_aug ],\n                Gs_M :[ C_aug ], A_M :[ F_aug ], Bb_M :[ D_aug ], B_M :[ G_aug ]})  Caution: all morphisms in a category should have distinct names. If not, this may lead to random and unexpected behavior.  Conversely, if one lowers any note of an augmented triad by a semitone, one gets a major triad. Since, there are three possible notes, this defines a relation (and not simply a function) from  Y  to  X . We will call this morphism \u548c.  ## We create a category morphism with name  \u548c , domain Y, and codomain X\nJ = CatMorphism(u \u548c ,Y,X)\nJ.set_mapping({ C_aug :[ C_M , E_M , Gs_M ],\n                F_aug :[ Cs_M , F_M , A_M ],\n                D_aug :[ D_M , Fs_M , Bb_M ],\n                G_aug :[ Eb_M , G_M , B_M ]})  We now create the category generated by the two objects  X  and  Y , and the three morphisms  T , \u540c, and \u548c. For this, we instantiate  opycleid.categoryaction.CategoryAction  and specify the objects and the generators.  from opycleid.categoryaction import CategoryAction\n\nmy_category = CategoryAction()\nmy_category.set_objects([X,Y])\nmy_category.add_generators([T,I,J])\nmy_category.generate_category()\nfor name_f,f in my_category.get_morphisms():\n  print(name_f)\n'''\nThis prints the following list:\nT\nTT\nTTT\nTTTT\nTTTTT\nTTTTTT\nTTTTTTT\nTTTTTTTT\nTTTTTTTTT\nTTTTTTTTTT\nTTTTTTTTTTT\nTTT\u548c\nTT\u548c\nT\u548c\nid_X\nid_Y\n\u540c\n\u540cT\n\u540cTT\n\u540cTTT\n\u540cTTT\u548c\n\u540cTT\u548c\n\u540cT\u548c\n\u548c\n\u548c\u540c\n\u548c\u540cT\n\u548c\u540cTT\n\u548c\u540cTTT\n'''    During the generation process, the names are obtained by concatenation. We can ask Opycleid to rewrite these operations.  my_category.rewrite_operations()\nfor name_f,f in my_category.get_morphisms():\n  print(name_f)\n'''\nThis prints the following list:\n(T^10)\n(T^11)\n(T^2)\n(T^2)\u548c\n(T^3)\n(T^3)\u548c\n(T^4)\n(T^5)\n(T^6)\n(T^7)\n(T^8)\n(T^9)\nT\nT\u548c\nid_X\nid_Y\n\u540c\n\u540c(T^2)\n\u540c(T^2)\u548c\n\u540c(T^3)\n\u540c(T^3)\u548c\n\u540cT\n\u540cT\u548c\n\u548c\n\u548c\u540c\n\u548c\u540c(T^2)\n\u548c\u540c(T^3)\n\u548c\u540cT\n'''  (Depending on your operating system, the name of the operations above might not be the same, but the relations they represent are)  Note:  the rewriting process of Opycleid is very basic, and only tries to identify repeated consecutive sequences of generators names.  Our category is such that   There are 16 morphisms from  X  to  X :  12 of the form  T^p  with  p=0\\ldots11  ( T^0  being  \\text{id_X} ), and  4 of the form  T^p\u548c\u540c  with  p=0\\ldots3  (here \u548c\u540c(T^3), \u548c\u540c(T^2), \u548c\u540cT, and \u548c\u540c, since  T^p\u548c\u540c=\u548c\u540cT^p  as can be verified directly in Opycleid).    There are 4 morphisms from  Y  to  Y :  of the form  \u540cT^p\u548c  with  p=0\\ldots3  ( \u540c\u548c  being equal to  \\text{id_Y} )    There are 4 morphisms from  X  to  Y :  of the form  \u540cT^p  with  p=0\\ldots3     There are 4 morphisms from  Y  to  X :  of the form  T^p\u548c  with  p=0\\ldots3      Now that our category is generated, we can use it for analyzing transformations between chords.\nFor example, we could ask what are the transformations between  E  major and  A  major.  print(my_category.get_operation( E_M , A_M ))\n## Prints ['(T^5)', '\u548c\u540cT']  Indeed we can just transpose  E  major by five semitone higher, using  T^{5} , or we can transform  E  major to  C  augmented using \u540c, then to  G\\sharp  major by using \u548c, and finally to  A  major by using  T .",
            "title": "Defining custom morphisms and category actions"
        },
        {
            "location": "/gettingstarted/#defining-monoid-action-morphisms",
            "text": "In the framework of Opycleid, an instance of  opycleid.categoryaction.CategoryAction  is a concrete implementation of a faithful functor   S \\colon \\mathbf{C} \\to \\mathbf{Rel}  ,\nwhere   \\mathbf{C}   is a small category, and   \\mathbf{Rel}   is the 2-category of finite sets and relations. Such a functor defines a \"context\" for the analysis: in the example above, we worked in the set of the major and minor triads, or in the two distinct sets of major triads and augmented triads.  It is naturally to ask whether an analysis context can be changed. This is the role of  category action morphisms . By definition, a morphism between two category actions   S \\colon \\mathbf{C} \\to \\mathbf{Rel}   and   S' \\colon \\mathbf{C'} \\to \\mathbf{Rel}   is a pair   (N,\\nu)   where     N   is a functor from   \\mathbf{C}   to   \\mathbf{C'}  , and    \\nu   is a lax natural transformation from   S   to   S'N  .   When   \\mathbf{C}   and   \\mathbf{C'}   are monoids, the natural transformation   \\nu   is simply a morphism in   \\mathbf{Rel}   (i.e. a relation)\nbetween the sets   S(e)   and   S'(e')   ( e  and  e'  being the single objects of   \\mathbf{C}   and   \\mathbf{C'}  ),\nsuch that for any morphism   f   of   \\mathbf{C}   the relation   \\nu \\circ S(f)   is included in the relation   S'N(f) \\circ \\nu  .  Currently, Opycleid only allows the definition of monoid action morphisms.  To illustrate the notion, consider the   T\\text{/}I   group introduced previously. This is an extension   1 \\to \\mathbb{Z}_{12} \\to T\\text{/}I \\to \\mathbb{Z}_{2} \\to 1 , where the homomorphism   \\pi \\colon T\\text{/}I \\to \\mathbb{Z}_{2}   sends the transposition operations  T^p  to the identity of   \\mathbb{Z}_{2}  , whereas the inversion operations  I^p  are sent to the non-trivial element of   \\mathbb{Z}_{2}  . The group   \\mathbb{Z}_{2}   can be made to act on the set of  \\{major,minor\\}  of chord types in an obvious manner. We can are then going to build a monoid action morphism between these two monoid actions.  First, we define the group   \\mathbb{Z}_{2}   and its action.  from opycleid.categoryaction import CatObject, CatMorphism, MonoidAction\n\nS = CatObject( S ,[ major , minor ])\n\nZ = CatMorphism( z ,S,S)\nZ.set_mapping({ major :[ minor ], minor :[ major ]})\n\nZ2_group = MonoidAction()\nZ2_group.set_objects([S])\nZ2_group.add_generators([Z])\nZ2_group.generate_category()\nfor x in Z2_group.operations:\n    print(x)\n## This prints 'z', id_S' as expected      We also need to instantiate the   T\\text{/}I   group  from opycleid.musicmonoids import TI_Group_Triads\n\nti_group = TI_Group_Triads()  To define the monoid action morphism, we need to define the mapping on operations (which defines the functor  N ), and the mapping on elements (which defines the natural transformation  \\nu ).  operation_mapping={ id_. : id_S , T1 : id_S , T2 : id_S , T3 : id_S ,\n                    T4 : id_S , T5 : id_S , T6 : id_S , T7 : id_S ,\n                    T8 : id_S , T9 : id_S , T10 : id_S , T11 : id_S ,\n                    I0 : z , I1 : z , I2 : z , I3 : z , I4 : z ,\n                    I5 : z , I6 : z , I7 : z , I8 : z , I9 : z ,\n                    I10 : z , I11 : z }\nelements = [ C_M , Cs_M , D_M , Eb_M , E_M , F_M ,\n             Fs_M , G_M , Gs_M , A_M , Bb_M , B_M ,\n             C_m , Cs_m , D_m , Eb_m , E_m , F_m ,\n             Fs_m , G_m , Gs_m , A_m , Bb_m , B_m ]\nelement_mapping = {}\nfor x in elements:\n  if x[-1]== M :\n    element_mapping[x]=[ major ]\n  else:\n    element_mapping[x]=[ minor ]  We then instantiate  opycleid.monoidactionmorphism.MonoidActionMorphism  by specifying the source, target, and the necessary mappings.  from opycleid.monoidactionmorphism import MonoidActionMorphism\n\naction_morphism = MonoidActionMorphism(ti_group,Z2_group,operation_mapping,element_mapping)  Finally we check that our monoid action morphism is a valid one (i.e. both the functor  N  and the natural transformation  \\nu  are valid).  print(action_morphism.is_monoidmorphism_valid())\n## True\nprint(action_morphism.is_nattransformation_valid())\n## True\n\n## The following is a wrap-up around the successive two methods above\nprint(action_morphism.is_valid())\n## True",
            "title": "Defining monoid action morphisms"
        },
        {
            "location": "/gettingstarted/#k-net-analysis",
            "text": "Opycleid provides the means to perform basic Klumpenhouwer network (K-Net) analysis.  Informally, a K-Net is a directed graph, the vertices of which are labelled with musical objects,\nand the arrows of which are labelled with transformations between them. Arrows are understood to be composable: the label\nof a resulting composite arrow should be equal to the label of the composition of the two original arrows.  A K-Net allows one to study the interconnections between different musical elements,\nfor example in the study of the different intervals in the constitutive elements of chords in post-tonal music.  Opycleid proposes a simplified version of this approach, by focusing on networks using monoid actions, in which vertices are labelled with singletons.\nTo illustrate this, we go back to the Beethoven example above, and create a K-net from the chord progression. We need to instantiate  opycleid.knetanalysis.KNet  by\nspecifying a monoid action, in our case the   T\\text{/}I   group.  from opycleid.musicmonoids import TI_Group_Triads\n\nti_group = TI_Group_Triads()\n\nfrom opycleid.knetanalysis import KNet\n\nmy_knet = KNet(ti_group)\nmy_knet.set_vertices([ C_M , A_m , F_M , D_m , Bb_M ])  Since the   T\\text{/}I   group is simply transitive, the determination of the musical transformations between the vertices is unambiguous, so we can call  path_knet_from_vertices()  to automatically determine them. Otherwise, edges have to be manually specified.  my_knet.path_knet_from_vertices()\nprint(str(my_knet))\n'''\nK-Net description:\n       I4   \n    C_M-- A_m\n       I9   \n    A_m-- F_M\n       I2   \n    F_M-- D_m\n       I7    \n    D_m-- Bb_M\n'''  Finally, we can transform a K-net into another by using a monoid action morphism. If we use the monoid action morphism we defined in the previous section, we get the following new K-net.  new_knet = my_knet.apply_knet_morphism(action_morphism)\nprint(str(new_knet))\n'''\nK-Net description:\n         z     \n    major- minor\n         z     \n    minor- major\n         z     \n    major- minor\n         z     \n    minor- major\n'''  As expected, we have transformed our original K-net describing chords and their transformations to a new K-net describing  chord types  and their transformations.",
            "title": "K-Net analysis"
        },
        {
            "location": "/categoryaction/",
            "text": "opycleid.categoryaction\n\n\nThis module defines the basic classes needed for building musical transformations.\n\n\nCatObject\n\n\nopycleid.categoryaction.CatObject(name,elements)\n\n\n\n\nDefines a category object, which is simply a named finite set. Elements of the set\nare indexed internally from 0 to len(elements).\n\n\nArguments\n\n\n\n\nname\n: a string used to name the set.\n\n\nelements\n: a list of strings representing the elements of the set.\n\n\n\n\n\n\nMethods\n\n\nget_idx_by_name\n\n\nget_idx_by_name(elem)\n\n\n\n\nReturns the integer index associated with the element \nelem\n. Raises an exception\nif the element cannot be found.\n\n\n\n\nget_name_by_idx\n\n\nget_name_by_idx(idx)\n\n\n\n\nReturns the element associated with the integer index \nidx\n.\n\n\n\n\nget_elements\n\n\nget_elements()\n\n\n\n\nReturns the list of elements contained in this set.\n\n\n\n\nget_cardinality\n\n\nget_cardinality()\n\n\n\n\nReturns the cardinality of the set.\n\n\n\n\nis_in\n\n\nis_in(elem)\n\n\n\n\nReturns \nTrue\n if the element \nelem\n is in the set.\n\n\n\n\nCatMorphism\n\n\nopycleid.categoryaction.CatMorphism(name,source,target)\n\n\n\n\nDefines a category morphism between two category objects. It is defined by its\nsource, its target, and a relation between the source sets and the target sets.\n\n\nArguments\n\n\n\n\nname\n: a string used to name the morphism.\n\n\nsource\n: an instance of \nopycleid.categoryaction.CatObject\n representing the source of the morphism.\n\n\ntarget\n: an instance of \nopycleid.categoryaction.CatObject\n representing the target of the morphism.\n\n\n\n\n\n\nMethods\n\n\nset_name\n\n\nset_name(name)\n\n\n\n\nSets the name of the morphism to \nname\n.\n\n\n\n\nset_to_identity\n\n\nset_to_identity()\n\n\n\n\nIf the source and target are identical, sets the morphism to be the identity on this category object,\ni.e. the relation between the corresponding sets is the identity function.\n\n\n\n\nset_mapping\n\n\nset_mapping(mapping)\n\n\n\n\nDefines the relation between the source sets and the target sets. The argument \nmapping\n should be a dictionary, whose keys are elements in the source set, and whose values are lists of elements in the target set corresponding to the images of the source elements by the given relation.\n\n\n\n\nset_mapping_matrix\n\n\nset_mapping_matrix(matrix)\n\n\n\n\nDefines the relation between the source sets and the target sets using a matrix description. The argument \nmapping\n should be a NumPy array of type \nbool\n. The rows of this matrix corresponds to the elements of the target sets, and the columns corresponds to the elements of the source sets, in both cases indexed as in the corresponding \nCatObject\n. Use only if you are sure about the correspondence between elements and element indices.\n\n\n\n\nget_mapping\n\n\nget_mapping()\n\n\n\n\nReturns the relation defined by this morphism as a dictionary, whose keys are elements in the source set, and whose values are lists of elements in the target set corresponding to the images of the source elements.\n\n\n\n\nget_mapping_matrix\n\n\nget_mapping_matrix()\n\n\n\n\nReturns the relation defined by this morphism as a NumPy array of type \nbool\n.\n\n\n\n\nstr\n\n\nOverloads Python \nstr\n to return a string description of the morphism, including its source, target, and the relation between them.\n\n\n\n\nrshift\n\n\nOverloads the \n operator in order to represent a morphism action.\nA typical use is \nCatMorphism \n elem\n where \nelem\n is a string representing an element in the source set.\nReturns a list of images in the target set.\n\n\n\n\nmul\n\n\nOverloads the \n*\n operator in order to represent morphism composition.\nA typical use is \nCatMorphism_2 * CatMorphism_1\n.\nIf the target of \nCatMorphism_1\n is identical to the source of \nCatMorphism_2\n, this returns the corresponding composite morphism.\nOtherwise, the two morphisms are not composable and an exception will be raised.\n\n\n\n\npow\n\n\nOverloads the \n**\n operator in order to represent morphism iterated multiplication.\nA typical use is \nCatMorphism ** int\n.\nIf \nCatMorphism\n is an endomorphism, i.e. its target is the same object as its source, this returns the corresponding iterated morphism. Otherwise, an exception will be raised.\n\n\n\n\neq\n\n\nOverloads the \n==\n operator in order to check for morphism equality.\nA typical use is \nCatMorphism_2 == CatMorphism_1\n.\nReturns \nTrue\n if the sources, targets, and relations of both morphisms are equal.\n\n\n\n\nlt\n\n\nOverloads the \n operator in order to check for morphism inclusion.\nA typical use is \nCatMorphism_2 \n CatMorphism_1\n.\nReturns \nTrue\n if the sources, and targets of both morphisms are equal, and if the relation of \nCatMorphism_2\n is included in the relation of \nCatMorphism_1\n.\n\n\n\n\nCategoryAction\n\n\nopycleid.categoryaction.CategoryAction()\n\n\n\n\nDefines a category action object, i.e. a faithful functor \n F \\colon \\mathbf{C} \\to \\mathbf{Rel} \n,\nwhere \n \\mathbf{C} \n is a small category, and \n \\mathbf{Rel} \n is the 2-category of finite sets and relations.\nInstances of this class store internally\n\n a dictionary of \nopycleid.categoryaction.CatObject\n instances, indexed by their name\n\n a dictionary of \nopycleid.categoryaction.CatMorphism\n instances, indexed by their name, corresponding to the generators of the category,\n* a dictionary of \nopycleid.categoryaction.CatMorphism\n instances, indexed by their name, corresponding to all the operations of the category.\n\n\n\n\nMethods\n\n\nset_objects\n\n\nset_objects(list_objects)\n\n\n\n\nThe argument \nlist_objects\n should be a list of \nopycleid.categoryaction.CatObject\n instances. Calling this method stores the \nCatObject\n instances\nin the internal dictionary, and resets the generators and operations of the category.\n\n\n\n\nadd_generators\n\n\nadd_generators(list_morphisms)\n\n\n\n\nThe argument \nlist_morphisms\n should be a list of \nopycleid.categoryaction.CatMorphism\n instances. These instances are added to the internal dictionary of generators.\n\n\n\n\nadd_morphisms\n\n\nadd_morphisms(list_morphisms)\n\n\n\n\nThe argument \nlist_morphisms\n should be a list of \nopycleid.categoryaction.CatMorphism\n instances. These instances are added to the internal dictionary of operations.\n\n\n\n\nadd_identities\n\n\nadd_identities()\n\n\n\n\nAdd identity operations to the internal dictionary of operations corresponding to all objects present in this category.\n\n\n\n\ngenerate_category\n\n\ngenerate_category()\n\n\n\n\nGenerates the category from the internal dictionary of generators. This means that for any operation \n f \n and any generator \n g \n of this category, the composite operation \n g \\circ f \n will be added to the internal dictionary of operations, if not already present, until the generation is complete.\n\n\n\n\nget_objects()\n\n\nget_objects()\n\n\n\n\nReturns the objects in this category, as a list of tuples \n(String,CatObject)\n, where the \nCatObject\n instance is an object of the category, and \nString\n corresponds to its name.\n\n\n\n\nget_generators()\n\n\nget_generators()\n\n\n\n\nReturns the objects in this category, as a list of tuples \n(String,CatMorphism)\n, where the \nCatMorphism\n instance is a generator morphism of the category, and \nString\n corresponds to its name.\n\n\n\n\nget_morphisms()\n\n\nget_morphisms()\n\n\n\n\nReturns the objects in this category, as a list of tuples \n(String,CatMorphism)\n, where the \nCatMorphism\n instance is a morphism of the category, and \nString\n corresponds to its name.\n\n\n\n\nrename_operation\n\n\nrename_operation(name,new_name)\n\n\n\n\nThe arguments \nname\n and \nnew_name\n are the name of a category operation, and the specified new name respectively.\nRenames an operation in the category.\n\n\n\n\nrewrite_operations\n\n\nrewrite_operations()\n\n\n\n\nRewrite/simplify operation names in the category. Calling this method will examine all operation names, trying to identify repeated instances of the names of the generators, and simplifying them to \"([name]^p)\" where p is the corresponding power.\n\n\n\n\nmult\n\n\nmult(operation_2,operation_1)\n\n\n\n\nThe arguments \noperation_2\n and \noperation_1\n are the names of category operations.\nReturns the name of the composite operation \n \\text{operation_2} \\circ \\text{operation_1} \n if present.\n\n\n\n\napply_operation\n\n\napply_operation(name,elem)\n\n\n\n\nThe argument \nname\n is the name of a category operation, and the argument \nelem\n is an element in its source set.\nReturns the images of \nelem\n by the category operation with name \nname\n.\n\n\n\n\nget_operation\n\n\nget_operation(elem_1,elem_2)\n\n\n\n\nThe arguments \nelem_1\n and \nelem_2\n are elements in the objects of the category.\nReturns all the operations \nf\n in the category such that \nelem_2\n is the image of \nelem_1\n by \n f \n.\n\n\n\n\nMonoidAction\n\n\nopycleid.categoryaction.MonoidAction()\n\n\n\n\nDefines a monoid action object, i.e. a faithful functor \n F \\colon \\mathbf{C} \\to \\mathbf{Rel} \n,\nwhere \n \\mathbf{C} \n is a single-object category, and \n \\mathbf{Rel} \n is the 2-category of finite sets and relations.\nThis class inherits from \nopycleid.categoryaction.MonoidAction\n, and implements methods specific to the case of monoids and groups.\n\n\n\n\nMethods\n\n\nset_objects\n\n\nset_objects(list_objects)\n\n\n\n\nThis method is the same as the one in \nopycleid.categoryaction.CategoryAction\n, except that only a single instance of \nopycleid.categoryaction.CatObject\n is allowed in the list \nlist_objects\n.\n\n\n\n\nget_object\n\n\nget_object()\n\n\n\n\nReturns the single object of the monoid action as a tuple \n(String,CatObject)\n, where the \nCatObject\n instance is the single object of the monoid, and \nString\n corresponds to its name. This is equivalent to \nget_objects()[0]\n.\n\n\n\n\nget_automorphisms\n\n\nget_automorphisms()\n\n\n\n\nComputes all possible automorphisms of the monoid. Returns a list of dictionaries: each dictionary maps the generators (the keys) to their image in the monoid (the values).\n\n\nIn the current implementation, calling this method enumerates every mapping from the generators to the operations. It is not optimized, and therefore should not be used for large monoids.\n\n\n\n\nis_automorphism\n\n\nis_automorphism(autom_dict,full_map=False)\n\n\n\n\nChecks if a given mapping is a valid automorphism.\n\n\n\n\nautom_dict\n:  a dictionary, the keys of which are names of the generators, the values of which are names of operations corresponding to the image of the generators by the proposed automorphism.\n\n\nfull_map\n: a boolean indicating if the full automorphism mapping should be returned.\n\n\n\n\nReturns a tuple \n(valid,fullmapping)\n, where\n\n\n\n\nvalid\n is a boolean indicating if the map defined by \nautom_dict\n is a valid automorphism, and\n\n\nfullmapping\n is \nNone\n if \nfull_map=False\n, a dictionary mapping all operations of the monoid (keys) to their image (values) if \nfull_map=True\n.\n\n\n\n\n\n\nis_simplytransitive\n\n\nis_simplytransitive()\n\n\n\n\nChecks if the monoid acts simply transitively. Return \nTrue\n if it does.\n\n\n\n\nelement_Rclass\n\n\nelement_Rclass(operation)\n\n\n\n\nThe argument \noperation\n should be the name of an operation in the monoid. Generates the R class for the specified operation.\n\n\nNote\n: for a given morphism \n f \n, i.e. the R class is the set of all \n g \n such that we have \n f \\mathcal{R} g \n  for Green's \n \\mathcal{R}\n relation, i.e. \n f \\mathcal{R} g \n if \n fS = gS \n where \nS\n is the monoid.\n\n\n\n\nelement_Lclass\n\n\nelement_Lclass(operation)\n\n\n\n\nThe argument \noperation\n should be the name of an operation in the monoid. Generates the L class for the specified operation.\n\n\nNote\n: for a given morphism \n f \n, i.e. the L class is the set of all \n g \n such that we have \n f \\mathcal{L} g \n  for Green's \n \\mathcal{L}\n relation, i.e. \n f \\mathcal{L} g \n if \n Sf = Sg \n where \nS\n is the monoid.\n\n\n\n\nget_Rclasses\n\n\nget_Rclasses()\n\n\n\n\nReturns all R classes in this monoid as a list of lists, each list being an R class.\n\n\n\n\nget_Lclasses\n\n\nget_Lclasses()\n\n\n\n\nReturns all L classes in this monoid as a list of lists, each list being an L class.\n\n\n\n\nget_leftIdeals\n\n\nget_leftIdeals()\n\n\n\n\nReturns all left ideals in this monoid as a list of lists, each list being a left ideal.\nA left ideal is a subset \nX\n of the monoid, such that for any operation \nm\n in the monoid, \nmX\n is included in \nX\n.\n\n\n\n\nget_rightIdeals\n\n\nget_rightIdeals()\n\n\n\n\nReturns all right ideals in this monoid as a list of lists, each list being a right ideal.\nA right ideal is a subset \nX\n of the monoid, such that for any operation \nm\n in the monoid, \nXm\n is included in \nX\n.\n\n\n\n\nis_leftIdeal\n\n\nis_leftIdeal(S)\n\n\n\n\nReturns \nTrue\n if the subset \nS\n is a left ideal in the monoid.\n\n\n\n\nis_rightIdeal\n\n\nis_rightIdeal(S)\n\n\n\n\nReturns \nTrue\n if the subset \nS\n is a right ideal in the monoid.",
            "title": "opycleid.categoryaction"
        },
        {
            "location": "/categoryaction/#opycleidcategoryaction",
            "text": "This module defines the basic classes needed for building musical transformations.",
            "title": "opycleid.categoryaction"
        },
        {
            "location": "/categoryaction/#catobject",
            "text": "opycleid.categoryaction.CatObject(name,elements)  Defines a category object, which is simply a named finite set. Elements of the set\nare indexed internally from 0 to len(elements).",
            "title": "CatObject"
        },
        {
            "location": "/categoryaction/#arguments",
            "text": "name : a string used to name the set.  elements : a list of strings representing the elements of the set.",
            "title": "Arguments"
        },
        {
            "location": "/categoryaction/#methods",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/categoryaction/#get_idx_by_name",
            "text": "get_idx_by_name(elem)  Returns the integer index associated with the element  elem . Raises an exception\nif the element cannot be found.",
            "title": "get_idx_by_name"
        },
        {
            "location": "/categoryaction/#get_name_by_idx",
            "text": "get_name_by_idx(idx)  Returns the element associated with the integer index  idx .",
            "title": "get_name_by_idx"
        },
        {
            "location": "/categoryaction/#get_elements",
            "text": "get_elements()  Returns the list of elements contained in this set.",
            "title": "get_elements"
        },
        {
            "location": "/categoryaction/#get_cardinality",
            "text": "get_cardinality()  Returns the cardinality of the set.",
            "title": "get_cardinality"
        },
        {
            "location": "/categoryaction/#is_in",
            "text": "is_in(elem)  Returns  True  if the element  elem  is in the set.",
            "title": "is_in"
        },
        {
            "location": "/categoryaction/#catmorphism",
            "text": "opycleid.categoryaction.CatMorphism(name,source,target)  Defines a category morphism between two category objects. It is defined by its\nsource, its target, and a relation between the source sets and the target sets.",
            "title": "CatMorphism"
        },
        {
            "location": "/categoryaction/#arguments_1",
            "text": "name : a string used to name the morphism.  source : an instance of  opycleid.categoryaction.CatObject  representing the source of the morphism.  target : an instance of  opycleid.categoryaction.CatObject  representing the target of the morphism.",
            "title": "Arguments"
        },
        {
            "location": "/categoryaction/#methods_1",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/categoryaction/#set_name",
            "text": "set_name(name)  Sets the name of the morphism to  name .",
            "title": "set_name"
        },
        {
            "location": "/categoryaction/#set_to_identity",
            "text": "set_to_identity()  If the source and target are identical, sets the morphism to be the identity on this category object,\ni.e. the relation between the corresponding sets is the identity function.",
            "title": "set_to_identity"
        },
        {
            "location": "/categoryaction/#set_mapping",
            "text": "set_mapping(mapping)  Defines the relation between the source sets and the target sets. The argument  mapping  should be a dictionary, whose keys are elements in the source set, and whose values are lists of elements in the target set corresponding to the images of the source elements by the given relation.",
            "title": "set_mapping"
        },
        {
            "location": "/categoryaction/#set_mapping_matrix",
            "text": "set_mapping_matrix(matrix)  Defines the relation between the source sets and the target sets using a matrix description. The argument  mapping  should be a NumPy array of type  bool . The rows of this matrix corresponds to the elements of the target sets, and the columns corresponds to the elements of the source sets, in both cases indexed as in the corresponding  CatObject . Use only if you are sure about the correspondence between elements and element indices.",
            "title": "set_mapping_matrix"
        },
        {
            "location": "/categoryaction/#get_mapping",
            "text": "get_mapping()  Returns the relation defined by this morphism as a dictionary, whose keys are elements in the source set, and whose values are lists of elements in the target set corresponding to the images of the source elements.",
            "title": "get_mapping"
        },
        {
            "location": "/categoryaction/#get_mapping_matrix",
            "text": "get_mapping_matrix()  Returns the relation defined by this morphism as a NumPy array of type  bool .",
            "title": "get_mapping_matrix"
        },
        {
            "location": "/categoryaction/#str",
            "text": "Overloads Python  str  to return a string description of the morphism, including its source, target, and the relation between them.",
            "title": "str"
        },
        {
            "location": "/categoryaction/#rshift",
            "text": "Overloads the   operator in order to represent a morphism action.\nA typical use is  CatMorphism   elem  where  elem  is a string representing an element in the source set.\nReturns a list of images in the target set.",
            "title": "rshift"
        },
        {
            "location": "/categoryaction/#mul",
            "text": "Overloads the  *  operator in order to represent morphism composition.\nA typical use is  CatMorphism_2 * CatMorphism_1 .\nIf the target of  CatMorphism_1  is identical to the source of  CatMorphism_2 , this returns the corresponding composite morphism.\nOtherwise, the two morphisms are not composable and an exception will be raised.",
            "title": "mul"
        },
        {
            "location": "/categoryaction/#pow",
            "text": "Overloads the  **  operator in order to represent morphism iterated multiplication.\nA typical use is  CatMorphism ** int .\nIf  CatMorphism  is an endomorphism, i.e. its target is the same object as its source, this returns the corresponding iterated morphism. Otherwise, an exception will be raised.",
            "title": "pow"
        },
        {
            "location": "/categoryaction/#eq",
            "text": "Overloads the  ==  operator in order to check for morphism equality.\nA typical use is  CatMorphism_2 == CatMorphism_1 .\nReturns  True  if the sources, targets, and relations of both morphisms are equal.",
            "title": "eq"
        },
        {
            "location": "/categoryaction/#lt",
            "text": "Overloads the   operator in order to check for morphism inclusion.\nA typical use is  CatMorphism_2   CatMorphism_1 .\nReturns  True  if the sources, and targets of both morphisms are equal, and if the relation of  CatMorphism_2  is included in the relation of  CatMorphism_1 .",
            "title": "lt"
        },
        {
            "location": "/categoryaction/#categoryaction",
            "text": "opycleid.categoryaction.CategoryAction()  Defines a category action object, i.e. a faithful functor   F \\colon \\mathbf{C} \\to \\mathbf{Rel}  ,\nwhere   \\mathbf{C}   is a small category, and   \\mathbf{Rel}   is the 2-category of finite sets and relations.\nInstances of this class store internally  a dictionary of  opycleid.categoryaction.CatObject  instances, indexed by their name  a dictionary of  opycleid.categoryaction.CatMorphism  instances, indexed by their name, corresponding to the generators of the category,\n* a dictionary of  opycleid.categoryaction.CatMorphism  instances, indexed by their name, corresponding to all the operations of the category.",
            "title": "CategoryAction"
        },
        {
            "location": "/categoryaction/#methods_2",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/categoryaction/#set_objects",
            "text": "set_objects(list_objects)  The argument  list_objects  should be a list of  opycleid.categoryaction.CatObject  instances. Calling this method stores the  CatObject  instances\nin the internal dictionary, and resets the generators and operations of the category.",
            "title": "set_objects"
        },
        {
            "location": "/categoryaction/#add_generators",
            "text": "add_generators(list_morphisms)  The argument  list_morphisms  should be a list of  opycleid.categoryaction.CatMorphism  instances. These instances are added to the internal dictionary of generators.",
            "title": "add_generators"
        },
        {
            "location": "/categoryaction/#add_morphisms",
            "text": "add_morphisms(list_morphisms)  The argument  list_morphisms  should be a list of  opycleid.categoryaction.CatMorphism  instances. These instances are added to the internal dictionary of operations.",
            "title": "add_morphisms"
        },
        {
            "location": "/categoryaction/#add_identities",
            "text": "add_identities()  Add identity operations to the internal dictionary of operations corresponding to all objects present in this category.",
            "title": "add_identities"
        },
        {
            "location": "/categoryaction/#generate_category",
            "text": "generate_category()  Generates the category from the internal dictionary of generators. This means that for any operation   f   and any generator   g   of this category, the composite operation   g \\circ f   will be added to the internal dictionary of operations, if not already present, until the generation is complete.",
            "title": "generate_category"
        },
        {
            "location": "/categoryaction/#get_objects",
            "text": "get_objects()  Returns the objects in this category, as a list of tuples  (String,CatObject) , where the  CatObject  instance is an object of the category, and  String  corresponds to its name.",
            "title": "get_objects()"
        },
        {
            "location": "/categoryaction/#get_generators",
            "text": "get_generators()  Returns the objects in this category, as a list of tuples  (String,CatMorphism) , where the  CatMorphism  instance is a generator morphism of the category, and  String  corresponds to its name.",
            "title": "get_generators()"
        },
        {
            "location": "/categoryaction/#get_morphisms",
            "text": "get_morphisms()  Returns the objects in this category, as a list of tuples  (String,CatMorphism) , where the  CatMorphism  instance is a morphism of the category, and  String  corresponds to its name.",
            "title": "get_morphisms()"
        },
        {
            "location": "/categoryaction/#rename_operation",
            "text": "rename_operation(name,new_name)  The arguments  name  and  new_name  are the name of a category operation, and the specified new name respectively.\nRenames an operation in the category.",
            "title": "rename_operation"
        },
        {
            "location": "/categoryaction/#rewrite_operations",
            "text": "rewrite_operations()  Rewrite/simplify operation names in the category. Calling this method will examine all operation names, trying to identify repeated instances of the names of the generators, and simplifying them to \"([name]^p)\" where p is the corresponding power.",
            "title": "rewrite_operations"
        },
        {
            "location": "/categoryaction/#mult",
            "text": "mult(operation_2,operation_1)  The arguments  operation_2  and  operation_1  are the names of category operations.\nReturns the name of the composite operation   \\text{operation_2} \\circ \\text{operation_1}   if present.",
            "title": "mult"
        },
        {
            "location": "/categoryaction/#apply_operation",
            "text": "apply_operation(name,elem)  The argument  name  is the name of a category operation, and the argument  elem  is an element in its source set.\nReturns the images of  elem  by the category operation with name  name .",
            "title": "apply_operation"
        },
        {
            "location": "/categoryaction/#get_operation",
            "text": "get_operation(elem_1,elem_2)  The arguments  elem_1  and  elem_2  are elements in the objects of the category.\nReturns all the operations  f  in the category such that  elem_2  is the image of  elem_1  by   f  .",
            "title": "get_operation"
        },
        {
            "location": "/categoryaction/#monoidaction",
            "text": "opycleid.categoryaction.MonoidAction()  Defines a monoid action object, i.e. a faithful functor   F \\colon \\mathbf{C} \\to \\mathbf{Rel}  ,\nwhere   \\mathbf{C}   is a single-object category, and   \\mathbf{Rel}   is the 2-category of finite sets and relations.\nThis class inherits from  opycleid.categoryaction.MonoidAction , and implements methods specific to the case of monoids and groups.",
            "title": "MonoidAction"
        },
        {
            "location": "/categoryaction/#methods_3",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/categoryaction/#set_objects_1",
            "text": "set_objects(list_objects)  This method is the same as the one in  opycleid.categoryaction.CategoryAction , except that only a single instance of  opycleid.categoryaction.CatObject  is allowed in the list  list_objects .",
            "title": "set_objects"
        },
        {
            "location": "/categoryaction/#get_object",
            "text": "get_object()  Returns the single object of the monoid action as a tuple  (String,CatObject) , where the  CatObject  instance is the single object of the monoid, and  String  corresponds to its name. This is equivalent to  get_objects()[0] .",
            "title": "get_object"
        },
        {
            "location": "/categoryaction/#get_automorphisms",
            "text": "get_automorphisms()  Computes all possible automorphisms of the monoid. Returns a list of dictionaries: each dictionary maps the generators (the keys) to their image in the monoid (the values).  In the current implementation, calling this method enumerates every mapping from the generators to the operations. It is not optimized, and therefore should not be used for large monoids.",
            "title": "get_automorphisms"
        },
        {
            "location": "/categoryaction/#is_automorphism",
            "text": "is_automorphism(autom_dict,full_map=False)  Checks if a given mapping is a valid automorphism.   autom_dict :  a dictionary, the keys of which are names of the generators, the values of which are names of operations corresponding to the image of the generators by the proposed automorphism.  full_map : a boolean indicating if the full automorphism mapping should be returned.   Returns a tuple  (valid,fullmapping) , where   valid  is a boolean indicating if the map defined by  autom_dict  is a valid automorphism, and  fullmapping  is  None  if  full_map=False , a dictionary mapping all operations of the monoid (keys) to their image (values) if  full_map=True .",
            "title": "is_automorphism"
        },
        {
            "location": "/categoryaction/#is_simplytransitive",
            "text": "is_simplytransitive()  Checks if the monoid acts simply transitively. Return  True  if it does.",
            "title": "is_simplytransitive"
        },
        {
            "location": "/categoryaction/#element_rclass",
            "text": "element_Rclass(operation)  The argument  operation  should be the name of an operation in the monoid. Generates the R class for the specified operation.  Note : for a given morphism   f  , i.e. the R class is the set of all   g   such that we have   f \\mathcal{R} g    for Green's   \\mathcal{R}  relation, i.e.   f \\mathcal{R} g   if   fS = gS   where  S  is the monoid.",
            "title": "element_Rclass"
        },
        {
            "location": "/categoryaction/#element_lclass",
            "text": "element_Lclass(operation)  The argument  operation  should be the name of an operation in the monoid. Generates the L class for the specified operation.  Note : for a given morphism   f  , i.e. the L class is the set of all   g   such that we have   f \\mathcal{L} g    for Green's   \\mathcal{L}  relation, i.e.   f \\mathcal{L} g   if   Sf = Sg   where  S  is the monoid.",
            "title": "element_Lclass"
        },
        {
            "location": "/categoryaction/#get_rclasses",
            "text": "get_Rclasses()  Returns all R classes in this monoid as a list of lists, each list being an R class.",
            "title": "get_Rclasses"
        },
        {
            "location": "/categoryaction/#get_lclasses",
            "text": "get_Lclasses()  Returns all L classes in this monoid as a list of lists, each list being an L class.",
            "title": "get_Lclasses"
        },
        {
            "location": "/categoryaction/#get_leftideals",
            "text": "get_leftIdeals()  Returns all left ideals in this monoid as a list of lists, each list being a left ideal.\nA left ideal is a subset  X  of the monoid, such that for any operation  m  in the monoid,  mX  is included in  X .",
            "title": "get_leftIdeals"
        },
        {
            "location": "/categoryaction/#get_rightideals",
            "text": "get_rightIdeals()  Returns all right ideals in this monoid as a list of lists, each list being a right ideal.\nA right ideal is a subset  X  of the monoid, such that for any operation  m  in the monoid,  Xm  is included in  X .",
            "title": "get_rightIdeals"
        },
        {
            "location": "/categoryaction/#is_leftideal",
            "text": "is_leftIdeal(S)  Returns  True  if the subset  S  is a left ideal in the monoid.",
            "title": "is_leftIdeal"
        },
        {
            "location": "/categoryaction/#is_rightideal",
            "text": "is_rightIdeal(S)  Returns  True  if the subset  S  is a right ideal in the monoid.",
            "title": "is_rightIdeal"
        },
        {
            "location": "/musicmonoids/",
            "text": "opycleid.musicmonoids\n\n\nThis module includes musical monoids and groups commonly encountered in TMT.\n\n\nNoll_Monoid\n\n\nopycleid.musicmonoids.Noll_Monoid()\n\n\n\n\nThis monoid of 8 elements acts on the set of the twelve pitch classes \n \\{C,C\\sharp,D,E\\flat,E,F,F\\sharp,G,G\\sharp,A,B\\flat,B\\} \n encoded with the usual semi-tone encoding, i.e. the set \n \\mathbb{Z}_{12} \n with \n C=0, C\\sharp=1, \\text{etc.} \n.\n\n\nIt is defined by Thomas Noll as the monoid generated by the two transformations \n f \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12} \n and\n\n g \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12} \n such that\n\n f(x)= 3x+7,\n\nand\n\n g(x)= 8x+4.\n\n\n\n\nReferences\n\n\nThomas Noll: The topos of triads, In: Colloquium on Mathematical Music Theory, Volume 347 of Grazer Math. Ber. Karl-Franzens-Univ. Graz, pp. 103\u2013135, (2005).\n\n\n\n\nTI_Group_PC\n\n\nopycleid.musicmonoids.TI_Group_PC()\n\n\n\n\nThis group is the commonly named \n T\\text{/}I \n group which acts on the set of the twelve pitch classes \n \\{C,C\\sharp,D,E\\flat,E,F,F\\sharp,G,G\\sharp,A,B\\flat,B\\} \n encoded with the usual semi-tone encoding.\n\n\nIt is isomorphic to the dihedral group \n D_{24} \n of order 24, and is generated by the following two transformations.\n\n\n\n\nThe transformation \n T_1 \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12} \n is called the \ntransposition operation\n, and is such that \nT_1(x)=x+1\n\n\n\n\nThe transformation \n I_0 \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12} \n is called the \ninversion operation\n, and is such that \nI_0(x)=-x\n\n\n\n\n\n\nExample\n\n\nfrom opycleid.musicmonoids import TI_Group_PC\n\nmy_group = TI_Group_PC()\nprint(my_group.get_operation(\nD\n,\nA\n)) ## ['T7', 'I11']\nprint(my_group.apply_operation(\nI11\n,\nB\n)) ## ['C']\nprint(my_group.mult(\nI11\n,\nT3\n)) ## \nI8\n\n\n\n\n\nReferences\n\n\nAlissa S. Crans, Thomas M. Fiore \n Ramon Satyendra: Musical Actions of Dihedral Groups, The American Mathematical Monthly, 116:6, pp. 479-495, (2018).\n\n\n\n\nTI_Group_Triads\n\n\nopycleid.musicmonoids.TI_Group_Triads()\n\n\n\n\nThis group is the commonly named \n T\\text{/}I \n group which acts simply transitively on the set \n \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\}\n of the 24 major and minor triads, where \nn_M\n (resp. \nn_m\n) represents a major (resp. minor) triad with root \nn\n in the usual semi-tone encoding of pitch classes.\n\n\nIt is isomorphic to the dihedral group \n D_{24} \n of order 24, and is generated by the following two transformations.\n\n\n\n\nThe transformation \n T_1 \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12} \n is called the \ntransposition operation\n, and is such that \n T_1(n_M)=(n+1)_M, T_1(n_m)=(n+1)_m \n\n\n\n\nThe transformation \n I_0 \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12} \n is called the \ninversion operation\n, and is such that \n I_0(n_M)=(5-n)_m \n\n\n\n\n\n\nIn effect, the \n T_1\n and \n I_0\n operations act element-wise on the pitch classes constituting the chords.\n\n\nExample\n\n\nfrom opycleid.musicmonoids import TI_Group_Triads\n\nmy_group = TI_Group_Triads()\nprint(my_group.get_operation(\nE_M\n,\nGs_m\n)) ## ['I7']\nprint(my_group.apply_operation(\nI7\n,\nB_M\n)) ## ['Cs_m']\nprint(my_group.mult(\nI7\n,\nT4\n)) ## \nI3\n\n\n\n\n\nReferences\n\n\nAlissa S. Crans, Thomas M. Fiore \n Ramon Satyendra: Musical Actions of Dihedral Groups, The American Mathematical Monthly, 116:6, pp. 479-495, (2018).\n\n\n\n\nPRL_Group\n\n\nopycleid.musicmonoids.PRL_Group()\n\n\n\n\nThis group is the \n \\text{PRL} \n group commonly used in neo-Riemannian theory, which acts simply transitively on the set \n \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\}\n of the 24 major and minor triads, where \nn_M\n (resp. \nn_m\n) represents a major (resp. minor) triad with root \nn\n in the usual semi-tone encoding of pitch classes.\n\n\nIt is isomorphic to the dihedral group \n D_{24} \n of order 24, and is generated by the following two transformations.\n\n\n\n\nThe transformation \n L \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12} \n is called the \nleading-tone operation\n, and is such that \n L(n_M)=(n+4)_m\n\n\n\n\nThe transformation \n R \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12} \n is called the \nrelative operation\n, and is such that \n R(n_M)=(n+9)_m \n\n\n\n\n\n\nThough not a generator, the operation \n P = (RL)^3R \n, called the \nparallel operation\n, is often considered, and is such that \n P(n_M)=n_m \n.\n\n\nExample\n\n\nfrom opycleid.musicmonoids import PRL_Group\n\nmy_group = PRL_Group()\nprint(my_group.get_operation(\nE_M\n,\nGs_m\n)) ## ['L']\nprint(my_group.apply_operation(\nLPR\n,\nB_M\n)) ## ['C_m']\nprint(my_group.mult(\nR\n,\nLPR\n)) ## \nPL\n\n\n\n\n\nReferences\n\n\n\n\nAlissa S. Crans, Thomas M. Fiore \n Ramon Satyendra (2018): Musical Actions of Dihedral Groups, The American Mathematical Monthly, 116:6, 479-495.\n\n\nNeo-Riemannian theory\n.\n\n\n\n\n\n\nUTT_Group\n\n\nopycleid.musicmonoids.UTT_Group()\n\n\n\n\nThis group is called the group of \nUniform Triadic Transformations (UTT)\n and was introduced by Julian Hook in his Ph.D. dissertation. It acts on the set \n \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\}\n of the 24 major and minor triads, where \nn_M\n (resp. \nn_m\n) represents a major (resp. minor) triad with root \nn\n in the usual semi-tone encoding of pitch classes.\n\n\nThe UTT group is isomorphic to the wreath product \n \\mathbb{Z}_{12} \\wr \\mathbb{Z}_2 \n of order 288 and its elements are usually notated as \n (p,q,\\sigma) \n, with \np=0\\ldots11\n, \nq=0\\ldots11\n, and \n \\sigma \\in \\{+,-\\} \n. Their action is as follows.\n\n\n\n\nThe UTT \n (p,q,+) \n sends the major triad \n n_M \n to \n (n+p)_M \n, and the minor triad \n n_m \n to \n (n+q)_m \n.\n\n\nThe UTT \n (p,q,-) \n sends the major triad \n n_M \n to \n (n+p)_m \n, and the minor triad \n n_m \n to \n (n+q)_M \n.\n\n\n\n\nExample\n\n\nfrom opycleid.musicmonoids import UTT_Group\n\nmy_group = UTT_Group()\nprint(my_group.get_operation(\nE_M\n,\nGs_m\n))\n## Returns\n## ['\n4,1,-\n', '\n4,3,-\n', '\n4,9,-\n', '\n4,7,-\n', '\n4,2,-\n',\n##  '\n4,11,-\n', '\n4,6,-\n', '\n4,10,-\n', '\n4,4,-\n', '\n4,0,-\n',\n##  '\n4,5,-\n', '\n4,8,-\n']\nprint(my_group.apply_operation(\n7,6,-\n,\nA_M\n)) ## ['E_m']\nprint(my_group.mult(\n3,5,-\n,\n2,9,-\n)) ## \n7,0,+\n\n\n\n\n\nReferences\n\n\nJulian Hook: Uniform triadic transformations, Journal of Music Theory, 46(1/2), pp. 57\u2013126, (2002).\n\n\n\n\nLeft_Z3Q8_Group\n\n\nopycleid.musicmonoids.Left_Z3Q8_Group()\n\n\n\n\nLike the \n T\\text{/}I \n group and the \n \\text{PRL} \n group, this group is an extension of \n \\mathbb{Z}_{12} \n by \n \\mathbb{Z}_2 \n which acts simply transitively on the set \n \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\}\n of the 24 major and minor triads as defined above.\n\n\nIt is generated by the following two transformations.\n\n\n\n\nThe transformation \n T_1 \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12} \n such that \n T_1(n_M)=(n+1)_M, T_1(n_m)=(n+1)_m.\n\n\n\n\nThe transformation \n J_0 \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12} \n such that \n J_0(n_M)=(-n)_m, J_0(n_m)=(-n+6)_M.\n\n\n\n\n\n\nExample\n\n\nfrom opycleid.musicmonoids import Left_Z3Q8_Group\n\nmy_group = Left_Z3Q8_Group()\nprint(my_group.get_operation(\nE_M\n,\nGs_m\n)) ## ['J0']\nprint(my_group.apply_operation(\nJ0\n,\nGs_m\n)) ## ['Bb_M']\nprint(my_group.mult(\nJ3\n,\nT2\n)) ## \nJ1\n\n\n\n\n\nReferences\n\n\nAlexandre Popoff: Building Generalized Neo-Riemannian Groups of Musical Transformations as Extensions, Journal of Mathematics and Music, 7(1), pp. 55\u201372, (2013).\n\n\n\n\nRight_Z3Q8_Group\n\n\nopycleid.musicmonoids.Right_Z3Q8_Group()\n\n\n\n\nThis group is the right version of the 'Left_Z3Q8_Group' above. It also acts simply transitively on the set of major and minor triads, and is generated by the following two transformations.\n\n\n\n\nThe transformation \n T_1 \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12} \n such that \n T_1(n_M)=(n+1)_M, T_1(n_m)=(n-1)_m.\n\n\n\n\nThe transformation \n J_0 \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12} \n such that \n J_0(n_M)=n_m, J_0(n_m)=(n+6)_M.\n\n\n\n\n\n\nExample\n\n\nfrom opycleid.musicmonoids import Right_Z3Q8_Group\n\nmy_group = Right_Z3Q8_Group()\nprint(my_group.get_operation(\nE_M\n,\nGs_m\n)) ## ['J8']\nprint(my_group.apply_operation(\nJ0\n,\nGs_m\n)) ## ['D_M']\nprint(my_group.mult(\nJ3\n,\nT2\n)) ## \nJ1\n\n\n\n\n\nReferences\n\n\nAlexandre Popoff: Building Generalized Neo-Riemannian Groups of Musical Transformations as Extensions, Journal of Mathematics and Music, 7(1), pp. 55\u201372, (2013).\n\n\n\n\nUPL_Monoid\n\n\nopycleid.musicmonoids.UPL_Monoid()\n\n\n\n\nA monoid which acts on the set \n \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\} \\cup \\{n_{\\text{aug}}, n=0\\ldots3\\}\n of the 28 major, minor, and augmented triads, where \nn_M\n (resp. \nn_m\n, \nn_{\\text{aug}}\n) represents a major (resp. minor, augmented) triad with root \nn\n in the usual semi-tone encoding of pitch classes.\n\n\nIt is generated by the following three relations.\n\n\n\n\n\n\nThe relation \n \\mathcal{P} \n is the symmetric relation such that we have \n n_M \\mathcal{P} n_m\n for \n 0 \\leq n \\leq 11\n, and \nn_\\text{aug} \\mathcal{P} n_\\text{aug}\n for \n0 \\leq n \\leq 3\n. This is the relational analogue of the neo-Riemannian \nP\n operation.\n\n\n\n\n\n\nThe relation \n\\mathcal{L}\n is the symmetric relation such that we have \nn_M \\mathcal{L} (n+4)_m\n for \n0 \\leq n \\leq 11\n, and \nn_\\text{aug} \\mathcal{L} n_\\text{aug}\n for \n0 \\leq n \\leq 3\n. This is the relational analogue of the neo-Riemannian \nL\n operation.\n\n\n\n\n\n\nThe relation \n\\mathcal{U}\n is the symmetric relation such that we have \nn_M \\mathcal{U} (n \\pmod 4)_\\text{aug}\n for \n0 \\leq n \\leq 11\n, and \nn_m \\mathcal{U} ((n+3) \\pmod 4)_\\text{aug}\n for \n0 \\leq n \\leq 11\n. It relates major and minor triads to augmented triads.\n\n\n\n\n\n\nNote that for any of these generators, two triads are related if they differ by a single semi-tone move.\n\n\nExample\n\n\nfrom opycleid.musicmonoids import UPL_Monoid\n\nmy_group = UPL_Monoid()\nprint(my_group.get_operation(\nE_M\n,\nF_aug\n))\n## Returns ['PUPUU', 'UPUU', 'UPUPU', 'PUPUPU']\nprint(my_group.apply_operation(\nU\n,\nF_aug\n))\n## Returns ['Cs_M', 'F_M', 'A_M', 'D_m', 'Fs_m', 'Bb_m']\nprint(my_group.mult(\nU\n,\nUUPUU\n)) ## \nUPUU\n\n\n\n\n\nReferences\n\n\nAlexandre Popoff, Moreno Andreatta, Andr\u00e9e Ehresmann: Relational PK-Nets for Transformational Music Analysis, \narXiv:1611.02249\n.\n\n\n\n\nS_Monoid\n\n\nopycleid.musicmonoids.S_Monoid()\n\n\n\n\nA monoid which acts on the set \n \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\} \\cup \\{n_{\\text{aug}}, n=0\\ldots3\\}\n of the 28 major, minor, and augmented triads, where \nn_M\n (resp. \nn_m\n, \nn_{\\text{aug}}\n) represents a major (resp. minor, augmented) triad with root \nn\n in the usual semi-tone encoding of pitch classes.\n\n\nIt is generated by the \n\\mathcal{S}\n relation defined as the symmetric relation such that we have \n n_M \\mathcal{S} n_m \n, \n n_M \\mathcal{S} (n+4)_m\n, \nn_M \\mathcal{S} (n \\pmod{4})_\\text{aug}\n, and \nn_m \\mathcal{S} ((n+3) \\pmod{4})_\\text{aug}\n for \n0 \\leq n \\leq 11\n. This relations is the same as the \n\\mathcal{P}_{1,0}\n relation introduced by Douthett in his work on parsimonious graphs. Two triads are related by \n\\mathcal{S}\n if they differ by a single semi-tone move.\n\n\nExample\n\n\nfrom opycleid.musicmonoids import S_Monoid\n\nmy_group = S_Monoid()\nprint(my_group.get_operation(\nE_M\n,\nF_aug\n))\n## Returns ['SSSS', 'SSSSSS']\nprint(my_group.apply_operation(\nS\n,\nE_M\n))\n## Returns ['E_m', 'Gs_m', 'C_aug']\n\n\n\n\nReferences\n\n\nDouthett, J., Steinbach, P.: Parsimonious Graphs: A Study in Parsimony, Contextual Transformations, and Modes of Limited Transposition, Journal of Music Theory, 42(2), pp. 241-263, (1998).\n\n\n\n\nT_Monoid\n\n\nopycleid.musicmonoids.T_Monoid()\n\n\n\n\nA monoid which acts on the set \n \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\} \\cup \\{n_{\\text{aug}}, n=0\\ldots3\\}\n of the 28 major, minor, and augmented triads, where \nn_M\n (resp. \nn_m\n, \nn_{\\text{aug}}\n) represents a major (resp. minor, augmented) triad with root \nn\n in the usual semi-tone encoding of pitch classes.\n\n\nIt is generated by the \n\\mathcal{T}\n relation defined as the symmetric relation such that we have, for \n0 \\leq n \\leq 11 \n,\n\n\n\n\n\n\nn_M \\mathcal{T} (n+4)_M,\n\n\n\n\n\n\nn_M \\mathcal{T} (n+8)_M,\n\n\n\n\n\n\nn_m \\mathcal{T} (n+4)_m,\n\n\n\n\n\n\nn_m \\mathcal{T} (n+8)_m,\n\n\n\n\n\n\nn_M \\mathcal{T} (n+1)_m,\n\n\n\n\n\n\nn_M \\mathcal{T} (n+5)_m,\n\n\n\n\n\n\nn_M \\mathcal{T} ((n+3) \\pmod{4})_\\text{aug},\n and\n\n\n\n\nn_m \\mathcal{T} (n \\pmod{4})_\\text{aug}.\n\n\n\n\n\n\nThis relation is the same as the \n\\mathcal{P}_{2,0}\n relation introduced by Douthett in his work on parsimonious graphs. Two triads are related by \n\\mathcal{T}\n if they differ by two semi-tone moves.\n\n\nExample\n\n\nfrom opycleid.musicmonoids import T_Monoid\n\nmy_group = T_Monoid()\nprint(my_group.get_operation(\nE_M\n,\nF_aug\n))\n## Returns ['TT', 'TTT']\nprint(my_group.apply_operation(\nT\n,\nE_M\n))\n## Returns ['C_M', 'Gs_M', 'F_m', 'A_m', 'G_aug']\n\n\n\n\nReferences\n\n\nDouthett, J., Steinbach, P.: Parsimonious Graphs: A Study in Parsimony, Contextual Transformations, and Modes of Limited Transposition, Journal of Music Theory, 42(2), pp. 241-263, (1998).\n\n\n\n\nK_Monoid\n\n\nopycleid.musicmonoids.K_Monoid()\n\n\n\n\nA monoid which acts on the set \n \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\} \\cup \\{n_{\\text{aug}}, n=0\\ldots3\\}\n of the 28 major, minor, and augmented triads, where \nn_M\n (resp. \nn_m\n, \nn_{\\text{aug}}\n) represents a major (resp. minor, augmented) triad with root \nn\n in the usual semi-tone encoding of pitch classes.\n\n\nIt is generated by the \n\\mathcal{K}\n relation. This is the same as the \n\\mathcal{P}_{2,1}\n relation introduced by Douthett in his work on parsimonious graphs. Two triads are related by \n\\mathcal{K}\n if they differ by the movement of two notes by a semitone each, and the remaining note by a tone.\n\n\nReferences\n\n\nDouthett, J., Steinbach, P.: Parsimonious Graphs: A Study in Parsimony, Contextual Transformations, and Modes of Limited Transposition, Journal of Music Theory, 42(2), pp. 241-263, (1998).\n\n\n\n\nW_Monoid\n\n\nopycleid.musicmonoids.W_Monoid()\n\n\n\n\nA monoid which acts on the set \n \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\} \\cup \\{n_{\\text{aug}}, n=0\\ldots3\\}\n of the 28 major, minor, and augmented triads, where \nn_M\n (resp. \nn_m\n, \nn_{\\text{aug}}\n) represents a major (resp. minor, augmented) triad with root \nn\n in the usual semi-tone encoding of pitch classes.\n\n\nIt is generated by the \n\\mathcal{K}\n relation. This is the same as the \n\\mathcal{P}_{1,2}\n relation introduced by Douthett in his work on parsimonious graphs. Two triads are related by \n\\mathcal{K}\n if they differ by the movement of a single note by a semitone, and the remaining notes by a tone each.\n\n\nReferences\n\n\nDouthett, J., Steinbach, P.: Parsimonious Graphs: A Study in Parsimony, Contextual Transformations, and Modes of Limited Transposition, Journal of Music Theory, 42(2), pp. 241-263, (1998).\n\n\n\n\nST_Monoid\n\n\nopycleid.musicmonoids.ST_Monoid()\n\n\n\n\nA monoid which acts on the set \n \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\} \\cup \\{n_{\\text{aug}}, n=0\\ldots3\\}\n of the 28 major, minor, and augmented triads, where \nn_M\n (resp. \nn_m\n, \nn_{\\text{aug}}\n) represents a major (resp. minor, augmented) triad with root \nn\n in the usual semi-tone encoding of pitch classes.\n\n\nIt is generated by the two relations \n\\mathcal{S}\n and \n\\mathcal{T}\n described above.",
            "title": "opycleid.musicmonoids"
        },
        {
            "location": "/musicmonoids/#opycleidmusicmonoids",
            "text": "This module includes musical monoids and groups commonly encountered in TMT.",
            "title": "opycleid.musicmonoids"
        },
        {
            "location": "/musicmonoids/#noll_monoid",
            "text": "opycleid.musicmonoids.Noll_Monoid()  This monoid of 8 elements acts on the set of the twelve pitch classes   \\{C,C\\sharp,D,E\\flat,E,F,F\\sharp,G,G\\sharp,A,B\\flat,B\\}   encoded with the usual semi-tone encoding, i.e. the set   \\mathbb{Z}_{12}   with   C=0, C\\sharp=1, \\text{etc.}  .  It is defined by Thomas Noll as the monoid generated by the two transformations   f \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12}   and  g \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12}   such that  f(x)= 3x+7, \nand  g(x)= 8x+4.",
            "title": "Noll_Monoid"
        },
        {
            "location": "/musicmonoids/#references",
            "text": "Thomas Noll: The topos of triads, In: Colloquium on Mathematical Music Theory, Volume 347 of Grazer Math. Ber. Karl-Franzens-Univ. Graz, pp. 103\u2013135, (2005).",
            "title": "References"
        },
        {
            "location": "/musicmonoids/#ti_group_pc",
            "text": "opycleid.musicmonoids.TI_Group_PC()  This group is the commonly named   T\\text{/}I   group which acts on the set of the twelve pitch classes   \\{C,C\\sharp,D,E\\flat,E,F,F\\sharp,G,G\\sharp,A,B\\flat,B\\}   encoded with the usual semi-tone encoding.  It is isomorphic to the dihedral group   D_{24}   of order 24, and is generated by the following two transformations.   The transformation   T_1 \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12}   is called the  transposition operation , and is such that  T_1(x)=x+1   The transformation   I_0 \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12}   is called the  inversion operation , and is such that  I_0(x)=-x",
            "title": "TI_Group_PC"
        },
        {
            "location": "/musicmonoids/#example",
            "text": "from opycleid.musicmonoids import TI_Group_PC\n\nmy_group = TI_Group_PC()\nprint(my_group.get_operation( D , A )) ## ['T7', 'I11']\nprint(my_group.apply_operation( I11 , B )) ## ['C']\nprint(my_group.mult( I11 , T3 )) ##  I8",
            "title": "Example"
        },
        {
            "location": "/musicmonoids/#references_1",
            "text": "Alissa S. Crans, Thomas M. Fiore   Ramon Satyendra: Musical Actions of Dihedral Groups, The American Mathematical Monthly, 116:6, pp. 479-495, (2018).",
            "title": "References"
        },
        {
            "location": "/musicmonoids/#ti_group_triads",
            "text": "opycleid.musicmonoids.TI_Group_Triads()  This group is the commonly named   T\\text{/}I   group which acts simply transitively on the set   \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\}  of the 24 major and minor triads, where  n_M  (resp.  n_m ) represents a major (resp. minor) triad with root  n  in the usual semi-tone encoding of pitch classes.  It is isomorphic to the dihedral group   D_{24}   of order 24, and is generated by the following two transformations.   The transformation   T_1 \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12}   is called the  transposition operation , and is such that   T_1(n_M)=(n+1)_M, T_1(n_m)=(n+1)_m    The transformation   I_0 \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12}   is called the  inversion operation , and is such that   I_0(n_M)=(5-n)_m     In effect, the   T_1  and   I_0  operations act element-wise on the pitch classes constituting the chords.",
            "title": "TI_Group_Triads"
        },
        {
            "location": "/musicmonoids/#example_1",
            "text": "from opycleid.musicmonoids import TI_Group_Triads\n\nmy_group = TI_Group_Triads()\nprint(my_group.get_operation( E_M , Gs_m )) ## ['I7']\nprint(my_group.apply_operation( I7 , B_M )) ## ['Cs_m']\nprint(my_group.mult( I7 , T4 )) ##  I3",
            "title": "Example"
        },
        {
            "location": "/musicmonoids/#references_2",
            "text": "Alissa S. Crans, Thomas M. Fiore   Ramon Satyendra: Musical Actions of Dihedral Groups, The American Mathematical Monthly, 116:6, pp. 479-495, (2018).",
            "title": "References"
        },
        {
            "location": "/musicmonoids/#prl_group",
            "text": "opycleid.musicmonoids.PRL_Group()  This group is the   \\text{PRL}   group commonly used in neo-Riemannian theory, which acts simply transitively on the set   \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\}  of the 24 major and minor triads, where  n_M  (resp.  n_m ) represents a major (resp. minor) triad with root  n  in the usual semi-tone encoding of pitch classes.  It is isomorphic to the dihedral group   D_{24}   of order 24, and is generated by the following two transformations.   The transformation   L \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12}   is called the  leading-tone operation , and is such that   L(n_M)=(n+4)_m   The transformation   R \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12}   is called the  relative operation , and is such that   R(n_M)=(n+9)_m     Though not a generator, the operation   P = (RL)^3R  , called the  parallel operation , is often considered, and is such that   P(n_M)=n_m  .",
            "title": "PRL_Group"
        },
        {
            "location": "/musicmonoids/#example_2",
            "text": "from opycleid.musicmonoids import PRL_Group\n\nmy_group = PRL_Group()\nprint(my_group.get_operation( E_M , Gs_m )) ## ['L']\nprint(my_group.apply_operation( LPR , B_M )) ## ['C_m']\nprint(my_group.mult( R , LPR )) ##  PL",
            "title": "Example"
        },
        {
            "location": "/musicmonoids/#references_3",
            "text": "Alissa S. Crans, Thomas M. Fiore   Ramon Satyendra (2018): Musical Actions of Dihedral Groups, The American Mathematical Monthly, 116:6, 479-495.  Neo-Riemannian theory .",
            "title": "References"
        },
        {
            "location": "/musicmonoids/#utt_group",
            "text": "opycleid.musicmonoids.UTT_Group()  This group is called the group of  Uniform Triadic Transformations (UTT)  and was introduced by Julian Hook in his Ph.D. dissertation. It acts on the set   \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\}  of the 24 major and minor triads, where  n_M  (resp.  n_m ) represents a major (resp. minor) triad with root  n  in the usual semi-tone encoding of pitch classes.  The UTT group is isomorphic to the wreath product   \\mathbb{Z}_{12} \\wr \\mathbb{Z}_2   of order 288 and its elements are usually notated as   (p,q,\\sigma)  , with  p=0\\ldots11 ,  q=0\\ldots11 , and   \\sigma \\in \\{+,-\\}  . Their action is as follows.   The UTT   (p,q,+)   sends the major triad   n_M   to   (n+p)_M  , and the minor triad   n_m   to   (n+q)_m  .  The UTT   (p,q,-)   sends the major triad   n_M   to   (n+p)_m  , and the minor triad   n_m   to   (n+q)_M  .",
            "title": "UTT_Group"
        },
        {
            "location": "/musicmonoids/#example_3",
            "text": "from opycleid.musicmonoids import UTT_Group\n\nmy_group = UTT_Group()\nprint(my_group.get_operation( E_M , Gs_m ))\n## Returns\n## [' 4,1,- ', ' 4,3,- ', ' 4,9,- ', ' 4,7,- ', ' 4,2,- ',\n##  ' 4,11,- ', ' 4,6,- ', ' 4,10,- ', ' 4,4,- ', ' 4,0,- ',\n##  ' 4,5,- ', ' 4,8,- ']\nprint(my_group.apply_operation( 7,6,- , A_M )) ## ['E_m']\nprint(my_group.mult( 3,5,- , 2,9,- )) ##  7,0,+",
            "title": "Example"
        },
        {
            "location": "/musicmonoids/#references_4",
            "text": "Julian Hook: Uniform triadic transformations, Journal of Music Theory, 46(1/2), pp. 57\u2013126, (2002).",
            "title": "References"
        },
        {
            "location": "/musicmonoids/#left_z3q8_group",
            "text": "opycleid.musicmonoids.Left_Z3Q8_Group()  Like the   T\\text{/}I   group and the   \\text{PRL}   group, this group is an extension of   \\mathbb{Z}_{12}   by   \\mathbb{Z}_2   which acts simply transitively on the set   \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\}  of the 24 major and minor triads as defined above.  It is generated by the following two transformations.   The transformation   T_1 \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12}   such that   T_1(n_M)=(n+1)_M, T_1(n_m)=(n+1)_m.   The transformation   J_0 \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12}   such that   J_0(n_M)=(-n)_m, J_0(n_m)=(-n+6)_M.",
            "title": "Left_Z3Q8_Group"
        },
        {
            "location": "/musicmonoids/#example_4",
            "text": "from opycleid.musicmonoids import Left_Z3Q8_Group\n\nmy_group = Left_Z3Q8_Group()\nprint(my_group.get_operation( E_M , Gs_m )) ## ['J0']\nprint(my_group.apply_operation( J0 , Gs_m )) ## ['Bb_M']\nprint(my_group.mult( J3 , T2 )) ##  J1",
            "title": "Example"
        },
        {
            "location": "/musicmonoids/#references_5",
            "text": "Alexandre Popoff: Building Generalized Neo-Riemannian Groups of Musical Transformations as Extensions, Journal of Mathematics and Music, 7(1), pp. 55\u201372, (2013).",
            "title": "References"
        },
        {
            "location": "/musicmonoids/#right_z3q8_group",
            "text": "opycleid.musicmonoids.Right_Z3Q8_Group()  This group is the right version of the 'Left_Z3Q8_Group' above. It also acts simply transitively on the set of major and minor triads, and is generated by the following two transformations.   The transformation   T_1 \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12}   such that   T_1(n_M)=(n+1)_M, T_1(n_m)=(n-1)_m.   The transformation   J_0 \\colon \\mathbb{Z}_{12} \\to \\mathbb{Z}_{12}   such that   J_0(n_M)=n_m, J_0(n_m)=(n+6)_M.",
            "title": "Right_Z3Q8_Group"
        },
        {
            "location": "/musicmonoids/#example_5",
            "text": "from opycleid.musicmonoids import Right_Z3Q8_Group\n\nmy_group = Right_Z3Q8_Group()\nprint(my_group.get_operation( E_M , Gs_m )) ## ['J8']\nprint(my_group.apply_operation( J0 , Gs_m )) ## ['D_M']\nprint(my_group.mult( J3 , T2 )) ##  J1",
            "title": "Example"
        },
        {
            "location": "/musicmonoids/#references_6",
            "text": "Alexandre Popoff: Building Generalized Neo-Riemannian Groups of Musical Transformations as Extensions, Journal of Mathematics and Music, 7(1), pp. 55\u201372, (2013).",
            "title": "References"
        },
        {
            "location": "/musicmonoids/#upl_monoid",
            "text": "opycleid.musicmonoids.UPL_Monoid()  A monoid which acts on the set   \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\} \\cup \\{n_{\\text{aug}}, n=0\\ldots3\\}  of the 28 major, minor, and augmented triads, where  n_M  (resp.  n_m ,  n_{\\text{aug}} ) represents a major (resp. minor, augmented) triad with root  n  in the usual semi-tone encoding of pitch classes.  It is generated by the following three relations.    The relation   \\mathcal{P}   is the symmetric relation such that we have   n_M \\mathcal{P} n_m  for   0 \\leq n \\leq 11 , and  n_\\text{aug} \\mathcal{P} n_\\text{aug}  for  0 \\leq n \\leq 3 . This is the relational analogue of the neo-Riemannian  P  operation.    The relation  \\mathcal{L}  is the symmetric relation such that we have  n_M \\mathcal{L} (n+4)_m  for  0 \\leq n \\leq 11 , and  n_\\text{aug} \\mathcal{L} n_\\text{aug}  for  0 \\leq n \\leq 3 . This is the relational analogue of the neo-Riemannian  L  operation.    The relation  \\mathcal{U}  is the symmetric relation such that we have  n_M \\mathcal{U} (n \\pmod 4)_\\text{aug}  for  0 \\leq n \\leq 11 , and  n_m \\mathcal{U} ((n+3) \\pmod 4)_\\text{aug}  for  0 \\leq n \\leq 11 . It relates major and minor triads to augmented triads.    Note that for any of these generators, two triads are related if they differ by a single semi-tone move.",
            "title": "UPL_Monoid"
        },
        {
            "location": "/musicmonoids/#example_6",
            "text": "from opycleid.musicmonoids import UPL_Monoid\n\nmy_group = UPL_Monoid()\nprint(my_group.get_operation( E_M , F_aug ))\n## Returns ['PUPUU', 'UPUU', 'UPUPU', 'PUPUPU']\nprint(my_group.apply_operation( U , F_aug ))\n## Returns ['Cs_M', 'F_M', 'A_M', 'D_m', 'Fs_m', 'Bb_m']\nprint(my_group.mult( U , UUPUU )) ##  UPUU",
            "title": "Example"
        },
        {
            "location": "/musicmonoids/#references_7",
            "text": "Alexandre Popoff, Moreno Andreatta, Andr\u00e9e Ehresmann: Relational PK-Nets for Transformational Music Analysis,  arXiv:1611.02249 .",
            "title": "References"
        },
        {
            "location": "/musicmonoids/#s_monoid",
            "text": "opycleid.musicmonoids.S_Monoid()  A monoid which acts on the set   \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\} \\cup \\{n_{\\text{aug}}, n=0\\ldots3\\}  of the 28 major, minor, and augmented triads, where  n_M  (resp.  n_m ,  n_{\\text{aug}} ) represents a major (resp. minor, augmented) triad with root  n  in the usual semi-tone encoding of pitch classes.  It is generated by the  \\mathcal{S}  relation defined as the symmetric relation such that we have   n_M \\mathcal{S} n_m  ,   n_M \\mathcal{S} (n+4)_m ,  n_M \\mathcal{S} (n \\pmod{4})_\\text{aug} , and  n_m \\mathcal{S} ((n+3) \\pmod{4})_\\text{aug}  for  0 \\leq n \\leq 11 . This relations is the same as the  \\mathcal{P}_{1,0}  relation introduced by Douthett in his work on parsimonious graphs. Two triads are related by  \\mathcal{S}  if they differ by a single semi-tone move.",
            "title": "S_Monoid"
        },
        {
            "location": "/musicmonoids/#example_7",
            "text": "from opycleid.musicmonoids import S_Monoid\n\nmy_group = S_Monoid()\nprint(my_group.get_operation( E_M , F_aug ))\n## Returns ['SSSS', 'SSSSSS']\nprint(my_group.apply_operation( S , E_M ))\n## Returns ['E_m', 'Gs_m', 'C_aug']",
            "title": "Example"
        },
        {
            "location": "/musicmonoids/#references_8",
            "text": "Douthett, J., Steinbach, P.: Parsimonious Graphs: A Study in Parsimony, Contextual Transformations, and Modes of Limited Transposition, Journal of Music Theory, 42(2), pp. 241-263, (1998).",
            "title": "References"
        },
        {
            "location": "/musicmonoids/#t_monoid",
            "text": "opycleid.musicmonoids.T_Monoid()  A monoid which acts on the set   \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\} \\cup \\{n_{\\text{aug}}, n=0\\ldots3\\}  of the 28 major, minor, and augmented triads, where  n_M  (resp.  n_m ,  n_{\\text{aug}} ) represents a major (resp. minor, augmented) triad with root  n  in the usual semi-tone encoding of pitch classes.  It is generated by the  \\mathcal{T}  relation defined as the symmetric relation such that we have, for  0 \\leq n \\leq 11  ,    n_M \\mathcal{T} (n+4)_M,    n_M \\mathcal{T} (n+8)_M,    n_m \\mathcal{T} (n+4)_m,    n_m \\mathcal{T} (n+8)_m,    n_M \\mathcal{T} (n+1)_m,    n_M \\mathcal{T} (n+5)_m,    n_M \\mathcal{T} ((n+3) \\pmod{4})_\\text{aug},  and   n_m \\mathcal{T} (n \\pmod{4})_\\text{aug}.    This relation is the same as the  \\mathcal{P}_{2,0}  relation introduced by Douthett in his work on parsimonious graphs. Two triads are related by  \\mathcal{T}  if they differ by two semi-tone moves.",
            "title": "T_Monoid"
        },
        {
            "location": "/musicmonoids/#example_8",
            "text": "from opycleid.musicmonoids import T_Monoid\n\nmy_group = T_Monoid()\nprint(my_group.get_operation( E_M , F_aug ))\n## Returns ['TT', 'TTT']\nprint(my_group.apply_operation( T , E_M ))\n## Returns ['C_M', 'Gs_M', 'F_m', 'A_m', 'G_aug']",
            "title": "Example"
        },
        {
            "location": "/musicmonoids/#references_9",
            "text": "Douthett, J., Steinbach, P.: Parsimonious Graphs: A Study in Parsimony, Contextual Transformations, and Modes of Limited Transposition, Journal of Music Theory, 42(2), pp. 241-263, (1998).",
            "title": "References"
        },
        {
            "location": "/musicmonoids/#k_monoid",
            "text": "opycleid.musicmonoids.K_Monoid()  A monoid which acts on the set   \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\} \\cup \\{n_{\\text{aug}}, n=0\\ldots3\\}  of the 28 major, minor, and augmented triads, where  n_M  (resp.  n_m ,  n_{\\text{aug}} ) represents a major (resp. minor, augmented) triad with root  n  in the usual semi-tone encoding of pitch classes.  It is generated by the  \\mathcal{K}  relation. This is the same as the  \\mathcal{P}_{2,1}  relation introduced by Douthett in his work on parsimonious graphs. Two triads are related by  \\mathcal{K}  if they differ by the movement of two notes by a semitone each, and the remaining note by a tone.",
            "title": "K_Monoid"
        },
        {
            "location": "/musicmonoids/#references_10",
            "text": "Douthett, J., Steinbach, P.: Parsimonious Graphs: A Study in Parsimony, Contextual Transformations, and Modes of Limited Transposition, Journal of Music Theory, 42(2), pp. 241-263, (1998).",
            "title": "References"
        },
        {
            "location": "/musicmonoids/#w_monoid",
            "text": "opycleid.musicmonoids.W_Monoid()  A monoid which acts on the set   \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\} \\cup \\{n_{\\text{aug}}, n=0\\ldots3\\}  of the 28 major, minor, and augmented triads, where  n_M  (resp.  n_m ,  n_{\\text{aug}} ) represents a major (resp. minor, augmented) triad with root  n  in the usual semi-tone encoding of pitch classes.  It is generated by the  \\mathcal{K}  relation. This is the same as the  \\mathcal{P}_{1,2}  relation introduced by Douthett in his work on parsimonious graphs. Two triads are related by  \\mathcal{K}  if they differ by the movement of a single note by a semitone, and the remaining notes by a tone each.",
            "title": "W_Monoid"
        },
        {
            "location": "/musicmonoids/#references_11",
            "text": "Douthett, J., Steinbach, P.: Parsimonious Graphs: A Study in Parsimony, Contextual Transformations, and Modes of Limited Transposition, Journal of Music Theory, 42(2), pp. 241-263, (1998).",
            "title": "References"
        },
        {
            "location": "/musicmonoids/#st_monoid",
            "text": "opycleid.musicmonoids.ST_Monoid()  A monoid which acts on the set   \\{n_M, n=0\\ldots11\\} \\cup \\{n_m, n=0\\ldots11\\} \\cup \\{n_{\\text{aug}}, n=0\\ldots3\\}  of the 28 major, minor, and augmented triads, where  n_M  (resp.  n_m ,  n_{\\text{aug}} ) represents a major (resp. minor, augmented) triad with root  n  in the usual semi-tone encoding of pitch classes.  It is generated by the two relations  \\mathcal{S}  and  \\mathcal{T}  described above.",
            "title": "ST_Monoid"
        },
        {
            "location": "/monoidactionmorphism/",
            "text": "opycleid.monoidactionmorphism\n\n\nOverview\n\n\nIn the framework of Opycleid, a category action is a faithful functor \n S \\colon \\mathbf{C} \\to \\mathbf{Rel} \n,\nwhere \n \\mathbf{C} \n is a small category, and \n \\mathbf{Rel} \n is the 2-category of finite sets and relations.\n\n\nBy definition, a morphism between two category actions \n S \\colon \\mathbf{C} \\to \\mathbf{Rel} \n\nand \n S' \\colon \\mathbf{C'} \\to \\mathbf{Rel} \n is a pair \n (N,\\nu) \n where\n\n\n\n\n\n\n N \n is a functor from \n \\mathbf{C} \n to \n \\mathbf{C'} \n, and\n\n\n\n\n \\nu \n is a lax natural transformation from \n S \n to \n S'N \n.\n\n\n\n\nWhen \n \\mathbf{C} \n and \n \\mathbf{C'} \n are monoids, the natural transformation \n \\nu \n is simply a morphism in \n \\mathbf{Rel} \n (i.e. a relation)\nbetween the sets \n S(e) \n and \n S'(e') \n (\ne\n and \ne'\n being the single objects of \n \\mathbf{C} \n and \n \\mathbf{C'} \n),\nsuch that for any morphism \n f \n of \n \\mathbf{C} \n the relation \n \\nu \\circ S(f) \n is included in the relation \n S'N(f) \\circ \\nu \n.\n\n\nCurrently, Opycleid only allows the definition of monoid action morphisms.\n\n\n\n\nMonoidActionMorphism\n\n\nopycleid.monoidactionmorphism.MonoidActionMorphism(monoidaction_source,monoid_action_dest,monoid_morphism,nat_trans_mapping)\n\n\n\n\nDefines a monoid action morphism.\n\n\nArguments\n\n\n\n\nmonoidaction_source\n: an instance of \nopycleid.categoryaction.MonoidAction\n defining the source monoid action of the morphism.\n\n\nmonoidaction_dest\n: an instance of \nopycleid.categoryaction.MonoidAction\n defining the target monoid action of the morphism.\n\n\nmonoid_morphism\n: a dictionary defining the functor \n N \n. The keys are operations (as strings) in \nmonoidaction_source\n, the values are operations (as strings) in \nmonoidaction_dest\n.\n\n\nnat_trans_mapping\n: a dictionary defining the lax natural transformation \n \\nu \n. In the case of monoid actions, this is simply a relation between the image sets. The keys are elements of the object of \nmonoidaction_source\n, the values are list of elements of the object of \nmonoidaction_dest\n.\n\n\n\n\n\n\nMethods\n\n\nis_monoidmorphism_valid\n\n\nis_monoidmorphism_valid()\n\n\n\n\nChecks if the specified monoid morphism is a valid one.\nFor any two morphisms \nf_1,f_2\n of \n \\mathbf{C} \n, the specified monoid morphism \n N \n should be such\nthat \n N(f_2 * f_1) =  N(f_2) * N(f_1) \n.\nReturns \nTrue\n if this condition is fullfilled.\n\n\n\n\nis_nattransformation_valid\n\n\nis_nattransformation_valid()\n\n\n\n\nChecks if the specified natural transformation is a valid one.\nFor any morphism \n f \n of \n \\mathbf{C} \n the relation \n \\nu \\circ S(f) \n should be\nincluded in the relation \n S'N(f) \\circ \\nu \n.\nReturns \nTrue\n if this condition is fullfilled.\n\n\n\n\nis_valid\n\n\nis_valid()\n\n\n\n\nChecks if the specified monoid action morphism is a valid one.\nReturns \nTrue\n if both the given monoid morphism and the natural transformation are valid ones.",
            "title": "opycleid.monoidactionmorphism"
        },
        {
            "location": "/monoidactionmorphism/#opycleidmonoidactionmorphism",
            "text": "",
            "title": "opycleid.monoidactionmorphism"
        },
        {
            "location": "/monoidactionmorphism/#overview",
            "text": "In the framework of Opycleid, a category action is a faithful functor   S \\colon \\mathbf{C} \\to \\mathbf{Rel}  ,\nwhere   \\mathbf{C}   is a small category, and   \\mathbf{Rel}   is the 2-category of finite sets and relations.  By definition, a morphism between two category actions   S \\colon \\mathbf{C} \\to \\mathbf{Rel}  \nand   S' \\colon \\mathbf{C'} \\to \\mathbf{Rel}   is a pair   (N,\\nu)   where     N   is a functor from   \\mathbf{C}   to   \\mathbf{C'}  , and    \\nu   is a lax natural transformation from   S   to   S'N  .   When   \\mathbf{C}   and   \\mathbf{C'}   are monoids, the natural transformation   \\nu   is simply a morphism in   \\mathbf{Rel}   (i.e. a relation)\nbetween the sets   S(e)   and   S'(e')   ( e  and  e'  being the single objects of   \\mathbf{C}   and   \\mathbf{C'}  ),\nsuch that for any morphism   f   of   \\mathbf{C}   the relation   \\nu \\circ S(f)   is included in the relation   S'N(f) \\circ \\nu  .  Currently, Opycleid only allows the definition of monoid action morphisms.",
            "title": "Overview"
        },
        {
            "location": "/monoidactionmorphism/#monoidactionmorphism",
            "text": "opycleid.monoidactionmorphism.MonoidActionMorphism(monoidaction_source,monoid_action_dest,monoid_morphism,nat_trans_mapping)  Defines a monoid action morphism.",
            "title": "MonoidActionMorphism"
        },
        {
            "location": "/monoidactionmorphism/#arguments",
            "text": "monoidaction_source : an instance of  opycleid.categoryaction.MonoidAction  defining the source monoid action of the morphism.  monoidaction_dest : an instance of  opycleid.categoryaction.MonoidAction  defining the target monoid action of the morphism.  monoid_morphism : a dictionary defining the functor   N  . The keys are operations (as strings) in  monoidaction_source , the values are operations (as strings) in  monoidaction_dest .  nat_trans_mapping : a dictionary defining the lax natural transformation   \\nu  . In the case of monoid actions, this is simply a relation between the image sets. The keys are elements of the object of  monoidaction_source , the values are list of elements of the object of  monoidaction_dest .",
            "title": "Arguments"
        },
        {
            "location": "/monoidactionmorphism/#methods",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/monoidactionmorphism/#is_monoidmorphism_valid",
            "text": "is_monoidmorphism_valid()  Checks if the specified monoid morphism is a valid one.\nFor any two morphisms  f_1,f_2  of   \\mathbf{C}  , the specified monoid morphism   N   should be such\nthat   N(f_2 * f_1) =  N(f_2) * N(f_1)  .\nReturns  True  if this condition is fullfilled.",
            "title": "is_monoidmorphism_valid"
        },
        {
            "location": "/monoidactionmorphism/#is_nattransformation_valid",
            "text": "is_nattransformation_valid()  Checks if the specified natural transformation is a valid one.\nFor any morphism   f   of   \\mathbf{C}   the relation   \\nu \\circ S(f)   should be\nincluded in the relation   S'N(f) \\circ \\nu  .\nReturns  True  if this condition is fullfilled.",
            "title": "is_nattransformation_valid"
        },
        {
            "location": "/monoidactionmorphism/#is_valid",
            "text": "is_valid()  Checks if the specified monoid action morphism is a valid one.\nReturns  True  if both the given monoid morphism and the natural transformation are valid ones.",
            "title": "is_valid"
        },
        {
            "location": "/knetanalysis/",
            "text": "opycleid.knetanalysis\n\n\nOverview\n\n\nThis module defines a class for performing basic Klumpenhouwer network (K-Net) analysis.\n\n\nInformally, a K-Net is a directed graph, the vertices of which are labelled with musical objects,\nand the arrows of which are labelled with transformations between them. Arrows are understood to be composable: the label\nof a resulting composite arrow should be equal to the label of the composition of the two original arrows.\n\n\nA K-Net allows one to study the interconnections between different musical elements, for example in the study of the different intervals in the constitutive elements of chords in post-tonal music.\n\n\nRecent research (see below) has proposed new categorical formalizations of the K-Net notion, in which a K-Net can be conceived as the data \n (R,S,F,\\phi) \n of\n\n\n\n\na lax functor \n R \\colon \\Delta \\to \\mathbf{Rel} \n,\n\n\na functor \n S \\colon \\mathbf{C} \\to \\mathbf{Rel} \n where \n \\mathbf{C} \n is a small category, and\n\n\na category action morphism \n (F, \\phi) \n between them, i.e. a functor \n F \\colon \\Delta \\to \\mathbf{C} \n, and a lax natural transformation \n \\phi \\colon R \\to SF \n (left-total on all components).\n\n\n\n\nCategory action morphisms \n (N, \\nu) \n between functors \n S \\colon \\mathbf{C} \\to \\mathbf{Rel} \n and \n S' \\colon \\mathbf{C'} \\to \\mathbf{Rel} \n then allows one to define new K-Nets \n (R,S',F'=NF,\\phi'=\\nu \\circ \\phi) \n.\n\n\nOpycleid proposes a simplified version of this approach, by focusing on networks using monoid actions, in which vertices are labelled with singletons. Instances of \nopycleid.monoidactionmorphism.MonoidActionMorphism\n can be used to transform a K-Net into another.\nIn addition, Opycleid currently does not allow the underlying graph of the K-Net to have cycles.\nA K-Net is \nvalid\n if it does not contain any cycle, and if composability of the transformations on the edges is respected.\n\n\nReferences\n\n\nReference literature on Klumpenhouwer networks:\n\n\n\n\nDavid Lewin: Klumpenhouwer Networks and Some Isographies That Involve Them, Music Theory Spectrum, Vol. 12, pp. 83\u2013120, (1990).\n\n\nDavid Lewin: A Tutorial on Klumpenhouwer Networks, Using the Chorale in Schoenberg\u2019s Opus 11, No. 2, Journal of Music Theory, Vol. 38, pp. 79\u2013101, (1994).\n\n\nHenri Klumpenhouwer: The Inner and Outer Automorphisms of Pitch-Class Inversion and Transposition: Some Implications for Analysis with Klumpenhouwer Networks, Int\u00e9gral, Vol. 12, pp. 81\u201393, (1998).\n\n\n\n\nCategorical approaches to Klumpenhouwer networks:\n\n\n\n\nGuerino Mazzola, Moreno Andreatta: From a Categorical Point of View: K-Nets as Limit Denotators, Perspectives of New Music, 44(2), pp. 88\u2013113, (2006).\n\n\nAlexandre Popoff, Moreno Andreatta, Andr\u00e9e Ehresmann: A Categorical Generalization of Klumpenhouwer Networks, Proceedings of MCM 2015, Vol. 9110 of Lecture Notes in Computer Science, pp. 303\u2013314, Springer .\n\n\nAlexandre Popoff, Carlos Agon, Moreno Andreatta, Andr\u00e9e Ehresmann: From K-nets to PK-nets: a Categorical Approach, Perspectives of New Music, 54(2), pp. 5\u201363, (2016).\n\n\n\n\nKNet\n\n\nopycleid.knetanalysis.KNet(monoidaction)\n\n\n\n\nDefines a new K-Net.\nInstances of this class store internally\n\n an instance of \nopycleid.categoryaction.MonoidAction\n defining the monoid action used in the K-Net,\n\n a dictionary of vertices, the keys of which are integer indices, the values of which are strings representing musical elements in the single object of the monoid action,\n* a dictionary of edges, the keys of which are integer indices, the values of which are triples \n(id_s,id_t,label)\n where \nid_s\n is the integer index of the starting vertex, \nid_t\n is the integer index of the target vertex, and \nlabel\n is the name of an operation in the monoid action.\n\n\nArguments\n\n\n\n\nmonoidaction\n: an instance of \nopycleid.categoryaction.MonoidAction\n defining the monoid action used in the K-Net for labelling vertices and edges.\n\n\n\n\n\n\nMethods\n\n\nset_vertices\n\n\nset_vertices(list_edges)\n\n\n\n\nDefines the list of vertices for this K-Net. The argument \nlist_vertices\n is a list of strings representing musical elements in the single object of the defined monoid action. Calling this method erases previous data on edges.\n\n\n\n\nadd_edges\n\n\nadd_edges(list_vertices)\n\n\n\n\nAdds edges to this K-Net. The argument \nlist_edges\n is a list of triples \n(id_s,id_t,label)\n where \nid_s\n is the integer index of the starting vertex, \nid_t\n is the integer index of the target vertex, and \nlabel\n is the name of an operation in the monoid action. The method checks if \nlabel\n is a valid transformation between the musical elements at the corresponding vertices, and raises an exception if this is not the case.\n\n\n\n\npath_knet_from_vertices\n\n\npath_knet_from_vertices()\n\n\n\n\nAutomatically add edges to this K-Net. If \n n \n is the number of vertices in the K-Net, calling this method adds an edge between vertices \n i \n and \n i+1 \n for all \n i = 0\\ldots(n-1) \n. The determination of the edge label can only be done if the monoid action is simply transitive.\n\n\n\n\ncomplete_knet_from_vertices\n\n\ncomplete_knet_from_vertices()\n\n\n\n\nAutomatically add edges to this K-Net. If \n n \n is the number of vertices in the K-Net, calling this method adds an edge between vertices \n i \n and \n j \n for all \n i = 0\\ldots(n-1), j = 0\\ldots(n-1), j>i \n. The determination of the edge label can only be done if the monoid action is simply transitive.\n\n\n\n\nis_valid\n\n\nis_valid()\n\n\n\n\nChecks if the K-Net is a valid one, i.e. it does not contain any cycle, and composability of the transformations on the edges is respected. Returns \nTrue\n if valid.\n\n\n\n\napply_knet_morphism\n\n\napply_knet_morphism(monoidactionmorphism)\n\n\n\n\nTransforms a K-Net by applying a monoid action morphism. The argument \nmonoidactionmorphism\n should be an instance of \nopycleid.monoidactionmorphism.MonoidActionMorphism\n. Calling this method checks if the given monoid action morphism is a valid one, and returns a newly labelled K-Net if this is the case.\nNote that since Opycleid only allows networks in which vertices are labelled with singletons, monoid action morphisms in which musical elements have multiple images are not allowed.\n\n\n\n\nstr\n\n\nOverloads Python \nstr\n to return a string description of all edges in the K-Net.",
            "title": "opycleid.knetanalysis"
        },
        {
            "location": "/knetanalysis/#opycleidknetanalysis",
            "text": "",
            "title": "opycleid.knetanalysis"
        },
        {
            "location": "/knetanalysis/#overview",
            "text": "This module defines a class for performing basic Klumpenhouwer network (K-Net) analysis.  Informally, a K-Net is a directed graph, the vertices of which are labelled with musical objects,\nand the arrows of which are labelled with transformations between them. Arrows are understood to be composable: the label\nof a resulting composite arrow should be equal to the label of the composition of the two original arrows.  A K-Net allows one to study the interconnections between different musical elements, for example in the study of the different intervals in the constitutive elements of chords in post-tonal music.  Recent research (see below) has proposed new categorical formalizations of the K-Net notion, in which a K-Net can be conceived as the data   (R,S,F,\\phi)   of   a lax functor   R \\colon \\Delta \\to \\mathbf{Rel}  ,  a functor   S \\colon \\mathbf{C} \\to \\mathbf{Rel}   where   \\mathbf{C}   is a small category, and  a category action morphism   (F, \\phi)   between them, i.e. a functor   F \\colon \\Delta \\to \\mathbf{C}  , and a lax natural transformation   \\phi \\colon R \\to SF   (left-total on all components).   Category action morphisms   (N, \\nu)   between functors   S \\colon \\mathbf{C} \\to \\mathbf{Rel}   and   S' \\colon \\mathbf{C'} \\to \\mathbf{Rel}   then allows one to define new K-Nets   (R,S',F'=NF,\\phi'=\\nu \\circ \\phi)  .  Opycleid proposes a simplified version of this approach, by focusing on networks using monoid actions, in which vertices are labelled with singletons. Instances of  opycleid.monoidactionmorphism.MonoidActionMorphism  can be used to transform a K-Net into another.\nIn addition, Opycleid currently does not allow the underlying graph of the K-Net to have cycles.\nA K-Net is  valid  if it does not contain any cycle, and if composability of the transformations on the edges is respected.",
            "title": "Overview"
        },
        {
            "location": "/knetanalysis/#references",
            "text": "Reference literature on Klumpenhouwer networks:   David Lewin: Klumpenhouwer Networks and Some Isographies That Involve Them, Music Theory Spectrum, Vol. 12, pp. 83\u2013120, (1990).  David Lewin: A Tutorial on Klumpenhouwer Networks, Using the Chorale in Schoenberg\u2019s Opus 11, No. 2, Journal of Music Theory, Vol. 38, pp. 79\u2013101, (1994).  Henri Klumpenhouwer: The Inner and Outer Automorphisms of Pitch-Class Inversion and Transposition: Some Implications for Analysis with Klumpenhouwer Networks, Int\u00e9gral, Vol. 12, pp. 81\u201393, (1998).   Categorical approaches to Klumpenhouwer networks:   Guerino Mazzola, Moreno Andreatta: From a Categorical Point of View: K-Nets as Limit Denotators, Perspectives of New Music, 44(2), pp. 88\u2013113, (2006).  Alexandre Popoff, Moreno Andreatta, Andr\u00e9e Ehresmann: A Categorical Generalization of Klumpenhouwer Networks, Proceedings of MCM 2015, Vol. 9110 of Lecture Notes in Computer Science, pp. 303\u2013314, Springer .  Alexandre Popoff, Carlos Agon, Moreno Andreatta, Andr\u00e9e Ehresmann: From K-nets to PK-nets: a Categorical Approach, Perspectives of New Music, 54(2), pp. 5\u201363, (2016).",
            "title": "References"
        },
        {
            "location": "/knetanalysis/#knet",
            "text": "opycleid.knetanalysis.KNet(monoidaction)  Defines a new K-Net.\nInstances of this class store internally  an instance of  opycleid.categoryaction.MonoidAction  defining the monoid action used in the K-Net,  a dictionary of vertices, the keys of which are integer indices, the values of which are strings representing musical elements in the single object of the monoid action,\n* a dictionary of edges, the keys of which are integer indices, the values of which are triples  (id_s,id_t,label)  where  id_s  is the integer index of the starting vertex,  id_t  is the integer index of the target vertex, and  label  is the name of an operation in the monoid action.",
            "title": "KNet"
        },
        {
            "location": "/knetanalysis/#arguments",
            "text": "monoidaction : an instance of  opycleid.categoryaction.MonoidAction  defining the monoid action used in the K-Net for labelling vertices and edges.",
            "title": "Arguments"
        },
        {
            "location": "/knetanalysis/#methods",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/knetanalysis/#set_vertices",
            "text": "set_vertices(list_edges)  Defines the list of vertices for this K-Net. The argument  list_vertices  is a list of strings representing musical elements in the single object of the defined monoid action. Calling this method erases previous data on edges.",
            "title": "set_vertices"
        },
        {
            "location": "/knetanalysis/#add_edges",
            "text": "add_edges(list_vertices)  Adds edges to this K-Net. The argument  list_edges  is a list of triples  (id_s,id_t,label)  where  id_s  is the integer index of the starting vertex,  id_t  is the integer index of the target vertex, and  label  is the name of an operation in the monoid action. The method checks if  label  is a valid transformation between the musical elements at the corresponding vertices, and raises an exception if this is not the case.",
            "title": "add_edges"
        },
        {
            "location": "/knetanalysis/#path_knet_from_vertices",
            "text": "path_knet_from_vertices()  Automatically add edges to this K-Net. If   n   is the number of vertices in the K-Net, calling this method adds an edge between vertices   i   and   i+1   for all   i = 0\\ldots(n-1)  . The determination of the edge label can only be done if the monoid action is simply transitive.",
            "title": "path_knet_from_vertices"
        },
        {
            "location": "/knetanalysis/#complete_knet_from_vertices",
            "text": "complete_knet_from_vertices()  Automatically add edges to this K-Net. If   n   is the number of vertices in the K-Net, calling this method adds an edge between vertices   i   and   j   for all   i = 0\\ldots(n-1), j = 0\\ldots(n-1), j>i  . The determination of the edge label can only be done if the monoid action is simply transitive.",
            "title": "complete_knet_from_vertices"
        },
        {
            "location": "/knetanalysis/#is_valid",
            "text": "is_valid()  Checks if the K-Net is a valid one, i.e. it does not contain any cycle, and composability of the transformations on the edges is respected. Returns  True  if valid.",
            "title": "is_valid"
        },
        {
            "location": "/knetanalysis/#apply_knet_morphism",
            "text": "apply_knet_morphism(monoidactionmorphism)  Transforms a K-Net by applying a monoid action morphism. The argument  monoidactionmorphism  should be an instance of  opycleid.monoidactionmorphism.MonoidActionMorphism . Calling this method checks if the given monoid action morphism is a valid one, and returns a newly labelled K-Net if this is the case.\nNote that since Opycleid only allows networks in which vertices are labelled with singletons, monoid action morphisms in which musical elements have multiple images are not allowed.",
            "title": "apply_knet_morphism"
        },
        {
            "location": "/knetanalysis/#str",
            "text": "Overloads Python  str  to return a string description of all edges in the K-Net.",
            "title": "str"
        }
    ]
}